<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Overview &mdash; EverParse Manual  documentation</title><link rel="stylesheet" href="static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'en',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/doctools.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="3d: Dependent Data Descriptions for Verified Validation" href="3d.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            EverParse Manual
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="3d.html">3d: Dependent Data Descriptions for Verified Validation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="3d.html#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="3d.html#download-and-install">Download and install</a></li>
<li class="toctree-l2"><a class="reference internal" href="3d.html#run">Run</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="3d.html#language-reference">Language Reference</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-types">Base types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structs">Structs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bitfields">Bitfields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constants-and-enumerations">Constants and Enumerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-data-types">Parameterized data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tagged-unions-or-casetype">Tagged unions or <code class="docutils literal notranslate"><span class="pre">casetype</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays">Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#byte-sized-arrays">Byte-sized arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#singleton-arrays-of-variable-size">Singleton arrays of variable size</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#actions">Actions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#action-basics">Action basics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#restrictions">Restrictions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#alignment">Alignment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#variable-length-types">Variable-length Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#static-assertions-to-validate-alignment">Static Assertions to Validate Alignment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#explicitly-checking-3d-types-for-correspondence-with-existing-c-types">Explicitly checking 3d types for correspondence with existing C types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-code-with-for-several-compile-time-configurations">Generating code with for several compile-time configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#validating-data-with-indirections-or-pointers">Validating Data with Indirections or Pointers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pointer-types">Pointer Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#probing-pointers-a-first-example">Probing Pointers: A first example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#probing-multiple-indirections">Probing Multiple Indirections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#top-level-probes">Top-level Probes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coercing-pointer-types">Coercing Pointer Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-probe-callbacks">Multiple Probe Callbacks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nullable-pointers">Nullable Pointers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#an-end-to-end-executable-example">An End-to-end Executable Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#specialization-for-different-pointer-sizes">Specialization for Different Pointer Sizes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-first-example">A First Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#an-end-to-end-executable-example-1">An End-to-end Executable Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#limitations-on-variable-length-structures">Limitations on Variable-length Structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#and-end-to-end-example-with-variable-length-structures">And End-to-end Example with Variable-length Structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-forms-of-specialization">Other forms of Specialization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-copyright-notices-to-produced-c-h-files">Adding copyright notices to produced .c/.h files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modular-structure-and-files">Modular structure and files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">Error handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fully-worked-examples-tcp-segment-headers">Fully worked examples: TCP Segment Headers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generated-code">Generated code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling-1">Error handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#fully-worked-examples-elf-files">Fully worked examples: ELF files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integrating-elf-validator-in-existing-code">Integrating ELF validator in existing code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EverParse Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="3d.html">3d: Dependent Data Descriptions for Verified Validation</a></li>
      <li class="breadcrumb-item active">Overview</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <div class="section" id="overview">
<span id="d-lang"></span><h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<p>3d supports several fixed-width integer base types, (nested) structs,
constraints, enums, parameterized data types, tagged or otherwise
value-dependent unions, fixed-size arrays, and variable-size arrays.</p>
<p>In addition to data validation, 3d also supports <em>local actions</em> to pass values
read from the data structure, or pointers to them, to the caller code.</p>
<p>3d also supports validating structures that contain pointers, probing pointers
for validity and traversing them in order to validate the data they refer to.</p>
</div>
<div class="section" id="base-types">
<h1>Base types<a class="headerlink" href="#base-types" title="Permalink to this headline">¶</a></h1>
<p>The primitive types in 3d include unsigned integers of the following
flavors:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UINT8</span></code>: 8-bit unsigned little-endian integer</li>
<li>UINT16: 16-bit unsigned little-endian integer<ul>
<li>Literal values of <code class="docutils literal notranslate"><span class="pre">UINT8</span></code> are integers with the <code class="docutils literal notranslate"><span class="pre">uy</span></code> suffix, e.g.,
<code class="docutils literal notranslate"><span class="pre">0uy,</span> <span class="pre">8uy</span> <span class="pre">255uy</span></code> etc.</li>
<li>Literals can also be specified in hexadecimal, with hex digits in either
lower or upper case``0xabuy, 0x1Auy, 0xFFuy, 0xFfuy`` etc.</li>
<li>Literal values of <code class="docutils literal notranslate"><span class="pre">UINT8</span></code> are integers with the <code class="docutils literal notranslate"><span class="pre">uy</span></code> suffix, e.g.,
<code class="docutils literal notranslate"><span class="pre">0uy,</span> <span class="pre">8uy</span> <span class="pre">255uy</span></code> etc.</li>
<li>Literals can also be specified in hexadecimal, e.g., <code class="docutils literal notranslate"><span class="pre">0xabuy,</span> <span class="pre">0xffuy</span></code> etc.</li>
</ul>
</li>
<li>UINT32: 32-bit unsigned little-endian integer</li>
<li>UINT64: 64-bit unsigned little-endian integer</li>
</ul>
<p>Literal values of unsigned integer types can be specified in either decimal or
hexadecimal, e.g., <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">255</span></code> etc. in decimal; or in with hexadecimal with
either lower or upper case, e.g., <code class="docutils literal notranslate"><span class="pre">0x0,</span> <span class="pre">0x01,</span> <span class="pre">0xff,</span> <span class="pre">0xFF,</span> <span class="pre">0xFf</span></code> etc.</p>
<p>3d infers the smallest width of a literal based on type information, but the
width can also be specified explicitly.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">UINT8</span></code>, a literal has the <code class="docutils literal notranslate"><span class="pre">uy</span></code> suffix, e.g., <code class="docutils literal notranslate"><span class="pre">0uy,</span> <span class="pre">1uy,</span> <span class="pre">0xffuy,</span>
<span class="pre">255uy</span></code> etc.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">UINT16</span></code>, a literal has the <code class="docutils literal notranslate"><span class="pre">us</span></code> suffix, e.g., <code class="docutils literal notranslate"><span class="pre">0us,</span> <span class="pre">1us,</span> <span class="pre">0xffffus,</span>
<span class="pre">255us,</span> <span class="pre">65535us</span></code> etc.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">UINT32</span></code>, a literal has the <code class="docutils literal notranslate"><span class="pre">ul</span></code> suffix, e.g., <code class="docutils literal notranslate"><span class="pre">0ul,</span> <span class="pre">1ul,</span> <span class="pre">0xfffffffful,</span>
<span class="pre">255ul,</span> <span class="pre">4294967295ul</span></code> etc.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">UINT64</span></code>, a literal has the <code class="docutils literal notranslate"><span class="pre">uL</span></code> suffix, e.g., <code class="docutils literal notranslate"><span class="pre">0uL,</span> <span class="pre">1uL,</span> <span class="pre">0xffffffffffffffffuL,</span>
<span class="pre">255uL</span></code> etc.</p>
<p>We also provide big-endian unsigned integers:</p>
<ul class="simple">
<li>UINT16BE: 16-bit unsigned big-endian integer</li>
<li>UINT32BE: 32-bit unsigned big-endian integer</li>
<li>UINT64BE: 64-bit unsigned big-endian integer</li>
</ul>
<p>Big-endian integers are often useful in describing network message formats. 3d
ensures suitable endianness conversions are applied when comparing or equating
integers represented in different endianness. We show an example of this
<a class="reference internal" href="#sec-constraints"><span class="std std-ref">below</span></a>.</p>
</div>
<div class="section" id="structs">
<h1>Structs<a class="headerlink" href="#structs" title="Permalink to this headline">¶</a></h1>
<p>We would like to extract a validator for a simple point type, with X
and Y coordinates. So we create a file, <code class="docutils literal notranslate"><span class="pre">HelloWorld.3d</span></code>, with the
following 3d data format description:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _point {
  UINT16 x;
  UINT16 y;
} point;
</pre></div>
</div>
<p>This data format is very similar to a C type description, where
<code class="docutils literal notranslate"><span class="pre">UINT16</span></code> denotes the type of unsigned 16-bit integers, represented
as little-endian; with the addition of the <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code> keyword,
which tells 3d to expose the validator for the type to the final user.</p>
<p>Once we run <code class="docutils literal notranslate"><span class="pre">3d</span></code> with this file, we obtain several files:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">HelloWorld.c</span></code> and <code class="docutils literal notranslate"><span class="pre">HelloWorld.h</span></code>, which contain the actual verified
validators;</li>
<li><code class="docutils literal notranslate"><span class="pre">HelloWorldWrapper.c</span></code> and <code class="docutils literal notranslate"><span class="pre">HelloWorldWrapper.h</span></code>, which contain
entrypoint function definitions for data validators that the user
should ultimately use in their client code. More precisely, here is
the contents of <code class="docutils literal notranslate"><span class="pre">HelloWorldWrapper.h</span></code>:</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">HelloWorldCheckPoint</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">HelloWorldCheckPoint</span></code> function is the actual validator for the
<code class="docutils literal notranslate"><span class="pre">point</span></code> type. It takes an array of bytes, <code class="docutils literal notranslate"><span class="pre">base</span></code>, and its length
<code class="docutils literal notranslate"><span class="pre">len</span></code>, and it returns 1 if <code class="docutils literal notranslate"><span class="pre">base</span></code> starts with valid <code class="docutils literal notranslate"><span class="pre">point</span></code> data
that fits in <code class="docutils literal notranslate"><span class="pre">len</span></code> bytes or less, and 0 otherwise.</p>
<p>More generally, for a given <code class="docutils literal notranslate"><span class="pre">Module.3d</span></code>, a type definition <code class="docutils literal notranslate"><span class="pre">typ</span></code>
marked with <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code> tells 3d to expose its validator in
<code class="docutils literal notranslate"><span class="pre">ModuleWrapper.h</span></code> which will bear the name <code class="docutils literal notranslate"><span class="pre">ModuleCheckTyp</span></code>.</p>
<p>Structs can be nested, such as in the following instance:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _point {
  UINT16 x;
  UINT16 y;
} point;

<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _triangle {
  point a;
  point b;
  point c;
} triangle;
</pre></div>
</div>
<p>Then, since in this file the definition of <code class="docutils literal notranslate"><span class="pre">point</span></code> is not prefixed
with <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code>, only <code class="docutils literal notranslate"><span class="pre">triangle</span></code> will have its validator exposed
in <code class="docutils literal notranslate"><span class="pre">TriangleWrapper.h</span></code>.</p>
<p>There can be multiple definitions marked <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code> in a given
<code class="docutils literal notranslate"><span class="pre">.3d</span></code> file.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>By default, 3d does not enforce any alignment constraints, and does not
introduce any implicit alignment padding. So, for instance, in the following
data format description:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _point {
  UINT16 x;
  UINT16 y;
} point;

<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _coloredPoint1 {
  UINT8 color;
  point pt;
} coloredPoint1;

<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _coloredPoint2 {
  point pt;
  UINT8 color;
} coloredPoint2;
</pre></div>
</div>
<ul class="simple">
<li>in <code class="docutils literal notranslate"><span class="pre">coloredPoint1</span></code>, 3d will not introduce any padding between
the <code class="docutils literal notranslate"><span class="pre">color</span></code> field and the <code class="docutils literal notranslate"><span class="pre">pt</span></code> field;</li>
<li>in <code class="docutils literal notranslate"><span class="pre">coloredPoint2</span></code>, 3d will not introduce any padding after the
<code class="docutils literal notranslate"><span class="pre">color</span></code> field.</li>
</ul>
<p class="last">This is in the spirit of keeping 3d specifications explicit. However, 3d does
support an option to add alignment padding to a structure, as described
<a class="reference internal" href="#sec-alignment"><span class="std std-ref">below</span></a>.</p>
</div>
</div>
<div class="section" id="constraints">
<span id="sec-constraints"></span><h1>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h1>
<p>Validators for structs alone are only layout-related. Beyond that, 3d
provides a way to actually check for constraints on their field
values:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _smoker {
  UINT32 age { age &gt;= 21 };
  UINT8 cigarettesConsumed;
} smoker;
</pre></div>
</div>
<p>In this example, the validator for <code class="docutils literal notranslate"><span class="pre">smoker</span></code> will check that the
value of the <code class="docutils literal notranslate"><span class="pre">age</span></code> field is at least 21.</p>
<p>The constraint language includes integer arithmetic (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>,
<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) and
Boolean propositional logic (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code>)</p>
<p>Constraints on a field can also depend on the values of the previous
fields of the struct. For instance, here is a type definition for a
pair ordered by increasing values:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _orderedPair {
  UINT32 lesser;
  UINT32 greater { lesser &lt;= greater };
} orderedPair;
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Arithmetics on constraints are evaluated in machine integers, not
mathematical integers. Thus, the following naive definition:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _boundedSum {
  UINT32 left;
  UINT32 right { left + right &lt;= 42 };
} boundedSum;
</pre></div>
</div>
<p>will fail at F* verification because the expression <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">+</span> <span class="pre">right</span></code>
must be proven to not overflow <em>before</em> evaluating the condition. The
correct way of stating the condition is as follows:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _boundedSum {
  UINT32 left;
  UINT32 right { left &lt;= 42 &amp;&amp; right &lt;= 42 - left };
} boundedSum;
</pre></div>
</div>
<p class="last">This verifies because F* evaluates the right-hand-side
condition of a <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> in a context where the left-hand-side
condition is assumed to be true (thus <code class="docutils literal notranslate"><span class="pre">42</span> <span class="pre">-</span> <span class="pre">left</span></code> will not underflow.)</p>
</div>
</div>
<div class="section" id="bitfields">
<h1>Bitfields<a class="headerlink" href="#bitfields" title="Permalink to this headline">¶</a></h1>
<p>Like in C, the fields of a struct type in 3d can include bitfields,
i.e., unsigned integer types of user-specified width represented
packed within unsigned integer fields of the canonical sizes
UINT16, UINT32 and UINT64.</p>
<p>Consider the following example:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _BF {
  UINT32 x : 6;
  UINT32 y : 10 { y &lt;= 900 };
  UINT32 z : 16 { y + z &lt;= 60000 };
} BF;
</pre></div>
</div>
<p>This defines a struct <code class="docutils literal notranslate"><span class="pre">BF</span></code> occupying 32 bits of memory, where the
first 6 bits are for the field <code class="docutils literal notranslate"><span class="pre">x</span></code>; the next 10 bits are for the
field <code class="docutils literal notranslate"><span class="pre">y</span></code>; and the following 16 bits are for the field <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>The fields <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> can all be used in specifications
and are implicitly promoted to the underlying integer type, <code class="docutils literal notranslate"><span class="pre">UINT32</span></code>
in this case, although the 3d verifier is aware of suitable bounds on
the types, e.g., that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">64</span></code>.</p>
<p>For types <code class="docutils literal notranslate"><span class="pre">UINT8</span></code>. <code class="docutils literal notranslate"><span class="pre">UINT16</span></code>, <code class="docutils literal notranslate"><span class="pre">UINT32</span></code> and <code class="docutils literal notranslate"><span class="pre">UINT64</span></code>, 3d
implements <a class="reference external" href="https://learn.microsoft.com/en-us/cpp/c-language/c-bit-fields">MSVC’s rules for packing bit fields</a>:
least-significant bit first. For instance:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _BF2 {
  UINT16 x : 6;
  UINT16 y : 12;
  UINT8 z;
} BF2;
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">BF2</span></code>, although <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> cumulatively consume only
26 bits, the layout of <code class="docutils literal notranslate"><span class="pre">BF2</span></code> is actually as shown below, consuming
40 bits, since a given field must be represented within the bounds of
a single underlying type—we have 10 unused bits before <code class="docutils literal notranslate"><span class="pre">x</span></code> and 4
unused bits before <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>counting from most-significant bits to least-significant bits:

 0                   1                   2                   3                   4
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
|      Unused       |     x     | Unused|           y           |        z      |
|                   |           |       |                       |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
</div>
<p>EverParse version 2023.04.17 and beyond encode bitfields with
big-endian integer types <code class="docutils literal notranslate"><span class="pre">UINT16BE</span></code>, <code class="docutils literal notranslate"><span class="pre">UINT32BE</span></code> and <code class="docutils literal notranslate"><span class="pre">UINT64BE</span></code>
with the most-significant bit (MSB) first, which is necessary for many
IETF network protocols (“network byte order”.) Those versions of
EverParse introduce the integer type <code class="docutils literal notranslate"><span class="pre">UINT8BE</span></code> to read a 8-bit
bitfield as MSB-first.</p>
</div>
<div class="section" id="constants-and-enumerations">
<h1>Constants and Enumerations<a class="headerlink" href="#constants-and-enumerations" title="Permalink to this headline">¶</a></h1>
<p>3d provides a way to define numerical constants:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>#define red   1
#define green 2
#define blue  42
</pre></div>
</div>
<p>Alternatively, 3d provides a way to define enumerated types:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>UINT32 <span class="k">enum</span> color {
  red = 1,
  green,
  blue = 42
}

<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _coloredPoint {
  color col;
  UINT32 x;
  UINT32 y;
} coloredPoint;
</pre></div>
</div>
<p>The validator for <code class="docutils literal notranslate"><span class="pre">coloredPoint</span></code> will check that the value of
the field <code class="docutils literal notranslate"><span class="pre">col</span></code> is either 1, 2 (for <code class="docutils literal notranslate"><span class="pre">green</span></code>), or 42.</p>
<p>Contrary to structs, enum types cannot be marked <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code>.</p>
<p>The first enum label must be associated with a value.</p>
<p>The support type (here <code class="docutils literal notranslate"><span class="pre">UINT32</span></code>) must be the same type as the type
of the values associated to each label.</p>
<p>Due to a limitation in the way 3d currently checks for the absence of
double-fetches, values with enum type cannot be used in
constraints. For example, the following code is currently rejected.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>UINT32 <span class="k">enum</span> color {
  red = 1,
  green,
  blue = 42
};

<span class="k">typedef</span> <span class="k">struct</span> _enum_constraint {
  color col;
  UINT32 x
  {
     x == 0 || color == green
  };
} _enum_constraint ;
</pre></div>
</div>
<p>With the following error message:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(Error) The type of this field does not have a reader, either because its values are too large or because reading it may incur a double fetch; subsequent fields cannot depend on it
</pre></div>
</div>
<p>One must instead write:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>UINT32 <span class="k">enum</span> color {
    red = 1,
    green,
    blue = 42
};

<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _enum_constraint {
    UINT32 col
    {
       col == red ||
       col == green ||
       col == blue
    };
    UINT32 x
    {
       x == 0 || col == green
    };
} _enum_constraint ;
</pre></div>
</div>
<p>We expect to lift this limitation soon.</p>
</div>
<div class="section" id="parameterized-data-types">
<h1>Parameterized data types<a class="headerlink" href="#parameterized-data-types" title="Permalink to this headline">¶</a></h1>
<p>3d also offers the possibility to parameterize a data type description
with arguments that can then be reused in constraints. For instance,
the following <code class="docutils literal notranslate"><span class="pre">BoundedSum.3d</span></code> data description defines a pair of two
integers whose sum is bounded by a bound provided by the user as
argument:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _boundedSum (UINT32 bound) {
  UINT32 left;
  UINT32 right { left &lt;= bound &amp;&amp; right &lt;= bound - left };
} boundedSum;
</pre></div>
</div>
<p>Then, these arguments will show up as arguments of the
corresponding validator in the <code class="docutils literal notranslate"><span class="pre">BoundedSumWrapper.h</span></code> header produced
by 3d:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">BoundedSumCheckBoundedSum</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bound</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>Parameterized data types can also be instantiated within the <code class="docutils literal notranslate"><span class="pre">.3d</span></code>
file itself, including by the value of the field of a struct:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> mySum {
  UINT32 bound;
  boundedSum(bound) sum;
} mySum;
</pre></div>
</div>
<p>A parameterized data type can also check whether a condition on its
arguments holds before even trying to check its contents:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _boundedSum (UINT32 bound)
<span class="k">where</span> bound &lt;= 1729
{
  UINT32 left;
  UINT32 right { left &lt;= bound &amp;&amp; right &lt;= bound - left };
} boundedSum;
</pre></div>
</div>
<p>In this case, the validator for <code class="docutils literal notranslate"><span class="pre">boundedSum</span></code> would check
that <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">&lt;=</span> <span class="pre">1729</span></code>, before validating its fields.</p>
</div>
<div class="section" id="tagged-unions-or-casetype">
<h1>Tagged unions or <code class="docutils literal notranslate"><span class="pre">casetype</span></code><a class="headerlink" href="#tagged-unions-or-casetype" title="Permalink to this headline">¶</a></h1>
<p>3d supports <em>tagged unions</em>: a data type can store a value named <em>tag</em>
and a <em>payload</em> whose type depends on the tag value. The tag does not
need to be stored with the payload (e.g. it could be a parameter to the
type).</p>
<p>For instance, the following description defines the type of an integer
prefixed by its size in bits.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>#define size8  8
#define size16 16
#define size32 32

<span class="k">casetype</span> _int_payload (UINT32 size) {
  <span class="k">switch</span>(size) {
    <span class="k">case</span> size8:  UINT8  value8;
    <span class="k">case</span> size16: UINT16 value16;
    <span class="k">case</span> size32: UINT32 value32;
  }
} int_payload;

<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _integer {
  UINT32                size;
  int_payload(size) payload;
} integer;
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">3d does not enforce that all cases of a union be of the same size,
and 3d does not introduce any implicit padding to enforce it. Nor
does 3d introduce any alignment padding. This is in the spirit of
keeping 3d specifications explicit: if you want padding, you need to
add it explicitly. See also the section on <a class="reference internal" href="#sec-alignment"><span class="std std-ref">alignment</span></a>.</p>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">casetype</span></code> type actually defines an untagged union type dependent
on an argument value, which can be reused, e.g. for several types that
put different constraints on the value of the tag.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">casetype</span></code> type can also be marked <code class="docutils literal notranslate"><span class="pre">entrypoint</span></code>.</p>
<p>Rather than defining a top-level <code class="docutils literal notranslate"><span class="pre">casetype</span></code>, one can define a type by cases as
a field in a struct. For example, the following type is equivalent to the one
before:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _integer_alt {
  UINT32                size;
  <span class="k">switch</span> (size) {
    <span class="k">case</span> size8:  UINT8  value8;
    <span class="k">case</span> size16: UINT16 value16;
    <span class="k">case</span> size32: UINT32 value32;
  } payload;
} integer_alt;
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h1>
<p>A field in a struct or a casetype can be an array.</p>
<p>Arrays in 3d differ from arrays in C in a few important ways:</p>
<ul class="simple">
<li>Rather than counting elements, the size of an array in 3d is always
given in bytes.</li>
<li>Array sizes need not be a constant expression: any integer
expression is permissible for an array, so long as it fits in
<code class="docutils literal notranslate"><span class="pre">UINT32</span></code>. This allows expressing variable-sized arrays.</li>
</ul>
<p>3d supports several kinds of arrays.</p>
<div class="section" id="byte-sized-arrays">
<h2>Byte-sized arrays<a class="headerlink" href="#byte-sized-arrays" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">f[:byte-size</span> <span class="pre">n]</span></code></li>
</ul>
<p>The notation <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">f[:byte-size</span> <span class="pre">n]</span></code> describes a field named <code class="docutils literal notranslate"><span class="pre">f</span></code> holding an
array of elements of type <code class="docutils literal notranslate"><span class="pre">T</span></code> whose cumulative size in bytes is <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">=</span> <span class="pre">1</span></code>, 3d supports the notation <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">f[n]</span></code>, i.e., for
byte arrays, since the byte size and element count coincide, you need
not qualify the size of the array with a <code class="docutils literal notranslate"><span class="pre">:byte-size</span></code> qualifier.</p>
</div>
<div class="section" id="singleton-arrays-of-variable-size">
<h2>Singleton arrays of variable size<a class="headerlink" href="#singleton-arrays-of-variable-size" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">f[:byte-size-single-element-array</span> <span class="pre">n]</span></code></li>
</ul>
<p>In some cases, it is required to specify that a field contains a
single variable-sized element whose size in bytes is equal to a given
expression. The notation above introduces a field <code class="docutils literal notranslate"><span class="pre">f</span></code> that contains
a single element of type <code class="docutils literal notranslate"><span class="pre">T</span></code> occupying exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes.</p>
<p>A variation is:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">f[:byte-size-single-element-array-at-most</span> <span class="pre">n]</span></code></li>
</ul>
<p>which describes a field <code class="docutils literal notranslate"><span class="pre">f</span></code> that contains a single element of type
<code class="docutils literal notranslate"><span class="pre">T</span></code> occupying at most <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes, followed by padding bytes to make
up to <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes. This construct thus always consumes exactly <code class="docutils literal notranslate"><span class="pre">n</span></code>
bytes.</p>
<p>We expect to add several other kinds of variable-length array-like
types in the uture.</p>
</div>
</div>
<div class="section" id="actions">
<h1>Actions<a class="headerlink" href="#actions" title="Permalink to this headline">¶</a></h1>
<p>In addition to semantic constraints on types, 3d allows augmenting the
the fields of a struct or union with imperative actions, which allows
running certain user-chosen commands at specified points during
validation.</p>
<p>Let’s start with a simple example. Suppose you want to validate that a
byte array contains a pair of integers, and then read them into a
couple of mutable locations of your choosing. Here’s how:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _Pair(<span class="k">mutable</span> UINT32* x,
                     <span class="k">mutable</span> UINT32* y)
{
   UINT32 first
   {:on-success
        *x = first;
        <span class="k">return</span> true;
   };

   UINT32 second
   {:on-success
        *y = second;
        <span class="k">return</span> true;
   };
} Pair;
</pre></div>
</div>
<p>The struct <code class="docutils literal notranslate"><span class="pre">Pair</span></code> takes two out-parameters, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>. Out
parameters are signified by the <code class="docutils literal notranslate"><span class="pre">mutable</span></code> keyword and have pointer
types—in this case <code class="docutils literal notranslate"><span class="pre">UINT32*</span></code>. Each field in the struct is
augmented with an <code class="docutils literal notranslate"><span class="pre">on-success</span></code> action, where the action’s body is a
runs a small program snippet, which writes the <code class="docutils literal notranslate"><span class="pre">first</span></code> field into
<code class="docutils literal notranslate"><span class="pre">x</span></code>; the <code class="docutils literal notranslate"><span class="pre">second</span></code> field into <code class="docutils literal notranslate"><span class="pre">y</span></code>; and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> in both
cases. Actions can also return <code class="docutils literal notranslate"><span class="pre">false</span></code>, to signal that validation
should halt and signal failure.</p>
<p>Now, in greater detail:</p>
<div class="section" id="action-basics">
<h2>Action basics<a class="headerlink" href="#action-basics" title="Permalink to this headline">¶</a></h2>
<p>An action is a program composed from a few elements:</p>
<ul class="simple">
<li>Atomic actions: Basic commands to read and write variables</li>
<li>Variable bindings and sequential composition</li>
<li>Conditionals</li>
<li>External function calls</li>
</ul>
<p>An action is evaluated with respect to a handler (e.g.,
<code class="docutils literal notranslate"><span class="pre">on-success</span></code>) associated with a given field. We refer to this field
as the “base field” of the action.</p>
<p>An action is invoked by EverParse immediately after validating the
base field of the action. The action of the <code class="docutils literal notranslate"><span class="pre">on-success</span></code> handler is
invoked in case the field is valid (if preseent), otherwise the
<code class="docutils literal notranslate"><span class="pre">on-error</span></code> handler is invoked (if present).</p>
<p>The on-success handler can influence whether or not validation of the
other fields continues by returning a boolean—in case an on-success
action returns false, the validation of the type halts with an error.</p>
<p>The on-error handler also returns a boolean: in case it returns false,
the error code associated with the validator mentions that an
on-error handler failed; if it returns true, the error code is the
error code associated with the failed validation of the base field. In
both cases, validation halts with an error.</p>
<div class="section" id="atomic-actions">
<h3>Atomic actions<a class="headerlink" href="#atomic-actions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Expression <code class="docutils literal notranslate"><span class="pre">e</span></code> consist of variables and constants.</li>
<li><code class="docutils literal notranslate"><span class="pre">*i</span> <span class="pre">=</span> <span class="pre">e</span></code>: Assigns the value of the expressions <code class="docutils literal notranslate"><span class="pre">e</span></code> to the memory referenced by the pointer <code class="docutils literal notranslate"><span class="pre">i</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">*i</span></code>: Dereferences the pointer <code class="docutils literal notranslate"><span class="pre">i</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">field_pos</span></code>: Returns the offset of base field of the action from
the base of the validation buffer as a <code class="docutils literal notranslate"><span class="pre">UINT32</span></code> value.</li>
<li><code class="docutils literal notranslate"><span class="pre">field_ptr</span></code>: Returns a pointer to base field of the action as a
<code class="docutils literal notranslate"><span class="pre">PUINT8</span></code>, i.e., an abstract pointer to a <code class="docutils literal notranslate"><span class="pre">UINT8</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">e</span></code> Returns a boolean value <code class="docutils literal notranslate"><span class="pre">e</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">abort</span></code>: Causes the current validation process to fail.</li>
</ul>
</div>
<div class="section" id="composing-atomic-actions-sequentially-and-conditionally">
<h3>Composing atomic actions sequentially and conditionally<a class="headerlink" href="#composing-atomic-actions-sequentially-and-conditionally" title="Permalink to this headline">¶</a></h3>
<p>Composite actions can be built in a few ways:</p>
<ul class="simple">
<li>Atomic actions: For any atomic action <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">a;</span></code> (with a trailing
semicolon) is a composite action <code class="docutils literal notranslate"><span class="pre">p</span></code>.</li>
<li>Sequential composition: <code class="docutils literal notranslate"><span class="pre">`a;</span> <span class="pre">p</span></code> Given an atomic action <code class="docutils literal notranslate"><span class="pre">a</span></code>, and
a compositite action <code class="docutils literal notranslate"><span class="pre">p</span></code>, the form <code class="docutils literal notranslate"><span class="pre">a;p</span></code> runs <code class="docutils literal notranslate"><span class="pre">a</span></code> then <code class="docutils literal notranslate"><span class="pre">p</span></code>.</li>
<li>Variable binding: <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">a;</span> <span class="pre">p</span></code> Given an atomic action <code class="docutils literal notranslate"><span class="pre">a</span></code>,
and a compositite action <code class="docutils literal notranslate"><span class="pre">p</span></code>, the form <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">a;</span> <span class="pre">p</span></code> runs <code class="docutils literal notranslate"><span class="pre">a</span></code>,
stores its result in the new variable <code class="docutils literal notranslate"><span class="pre">x</span></code> (local to the
action), and then runs <code class="docutils literal notranslate"><span class="pre">p</span></code> (where <code class="docutils literal notranslate"><span class="pre">p</span></code> may mention <cite>x</cite></li>
<li>Conditionals: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(e)</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">}</span></code> is a conditional action that runs the
composite actions <code class="docutils literal notranslate"><span class="pre">p</span></code> only if the condition <code class="docutils literal notranslate"><span class="pre">e</span></code> is
true. Additionally, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(e)</span> <span class="pre">{</span> <span class="pre">p0</span> <span class="pre">}</span> <span class="pre">else</span> <span class="pre">{</span> <span class="pre">p1</span> <span class="pre">}</span></code> is also legal,
with the expected semantics, i.e., <code class="docutils literal notranslate"><span class="pre">p1`</span> <span class="pre">is</span> <span class="pre">run</span> <span class="pre">in</span> <span class="pre">case</span> <span class="pre">``e</span></code> is
false.</li>
<li>External function calls: an action can call a user-defined callback
C function. The user first needs to declare the callback function with
a top-level declaration in the 3D file: for instance,
<code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">UINT8</span> <span class="pre">myFunction(UINT32</span> <span class="pre">myArg1,</span> <span class="pre">UINT16</span> <span class="pre">myArg2)</span></code>
Then the user can call this function in an action, with
<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">myReturnValue</span> <span class="pre">=</span> <span class="pre">myFunction(e1,</span> <span class="pre">e2);</span></code>
The user can also declare a function that returns no value, with
<code class="docutils literal notranslate"><span class="pre">void</span></code> as its return type. Then, the user can call this function
directly as a statement in an action, without <code class="docutils literal notranslate"><span class="pre">var</span></code> :
<code class="docutils literal notranslate"><span class="pre">myFunction(e1,</span> <span class="pre">e2);</span></code>
An external function can also accept out-parameters, using
<code class="docutils literal notranslate"><span class="pre">mutable</span> <span class="pre">myType*</span> <span class="pre">myArg</span></code> in its 3D declaration.</li>
</ul>
</div>
<div class="section" id="another-example">
<h3>Another example<a class="headerlink" href="#another-example" title="Permalink to this headline">¶</a></h3>
<p>Consider the following definition:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _T(<span class="k">mutable</span> PUINT8* out) {
    UINT8 f1[10];
    UINT8 f2[20]
    {:on-success
        <span class="k">var</span> x = <span class="k">field_ptr</span>;
        *out = x;
        <span class="k">return</span> true;
    };
} T;
</pre></div>
</div>
<p>Here, we define a type <code class="docutils literal notranslate"><span class="pre">T</span></code> with an out-parameter <code class="docutils literal notranslate"><span class="pre">PUINT8*</span> <span class="pre">out</span></code>,
i.e., pointer to a pointer to a <code class="docutils literal notranslate"><span class="pre">UINT8</span></code>.</p>
<p>Associated with field <code class="docutils literal notranslate"><span class="pre">f2</span></code> we have an on-success handler, where we
read a pointer to the field <code class="docutils literal notranslate"><span class="pre">f2</span></code> into the local variable <code class="docutils literal notranslate"><span class="pre">x</span></code>;
then, we write <code class="docutils literal notranslate"><span class="pre">x</span></code> into <code class="docutils literal notranslate"><span class="pre">*out</span></code>; and finally return <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The return type of <code class="docutils literal notranslate"><span class="pre">field_ptr</span></code> is <code class="docutils literal notranslate"><span class="pre">PUINT8</span></code>. In
EverParse, a <code class="docutils literal notranslate"><span class="pre">PUINT8</span></code> is a pointer into the input buffer, unlike
a <code class="docutils literal notranslate"><span class="pre">UINT8*</span></code> which may point to any other memory. This distinction
between pointers into the input buffer and other pointers allows
EverParse to prove that validators never read the contents of the
input buffer more than once, i.e., there are no double fetches from
the input buffer. As such, the <code class="docutils literal notranslate"><span class="pre">out</span></code> parameter should have type
<code class="docutils literal notranslate"><span class="pre">PUINT8*</span></code> rather than <code class="docutils literal notranslate"><span class="pre">UINT8*</span></code>.</p>
</div>
</div>
<div class="section" id="actions-that-always-succeed">
<h3>Actions that always succeed<a class="headerlink" href="#actions-that-always-succeed" title="Permalink to this headline">¶</a></h3>
<p>For actions that always succeed, 3d supports a more concise notation, using the
<code class="docutils literal notranslate"><span class="pre">:act</span></code> form, as shown below:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _TAct(<span class="k">mutable</span> PUINT8* out) {
    UINT8 f1[10];
    UINT8 f2[20]
    {:act  <span class="k">var</span> x = <span class="k">field_ptr</span>; *out = x; };
} TAct;
</pre></div>
</div>
<p>This is equivalent to the prior <code class="docutils literal notranslate"><span class="pre">:on-success</span></code> action shown earlier.</p>
</div>
</div>
<div class="section" id="restrictions">
<h2>Restrictions<a class="headerlink" href="#restrictions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Actions can only be associated with fields.</li>
<li>Actions cannot be associated with the elements of an array, unless
the array elements themselves are defined types, in which case they
can be associated with the fields of that type, if any.</li>
<li>Actions cannot be associated with bit fields.</li>
</ul>
</div>
</div>
<div class="section" id="alignment">
<span id="sec-alignment"></span><h1>Alignment<a class="headerlink" href="#alignment" title="Permalink to this headline">¶</a></h1>
<p>As mentioned previously, 3d does not introduce any implicit alignment padding.
However, it is often convenient to use 3d to model the in-memory layout of a C
structure, including the alignment padding that a C compiler would insert.
Rather than requiring the user to manually insert padding fields, 3d allows
decorating a struct with an <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute, which instructs the 3d
frontend to add padding between fields modeling the behavior of a C compiler.
This page provides a useful reference about <a class="reference external" href="https://learn.microsoft.com/en-us/cpp/c-language/alignment-c?view=msvc-170">alignment padding in C</a>.</p>
<p>For example, consider the following structs:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _point {
  UINT16 x;
  UINT16 y;
} point;

<span class="k">aligned</span>
<span class="k">entrypoint</span> <span class="k">typedef</span> <span class="k">struct</span> _coloredPoint1 {
  UINT8 color;
  point pt;
} coloredPoint1;

<span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _coloredPoint2 {
  point pt;
  UINT8 color;
} coloredPoint2;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute to each struct adds alignment padding
between fields.</p>
<blockquote>
<div><ul class="simple">
<li>Both fields of the type <code class="docutils literal notranslate"><span class="pre">point</span></code> are aligned at 2-byte boundaries; so no
padding is inserted between them.</li>
<li>In type <code class="docutils literal notranslate"><span class="pre">coloredPoint1</span></code> the field <code class="docutils literal notranslate"><span class="pre">color</span></code> is aligned at a 1-byte boundary,
while <code class="docutils literal notranslate"><span class="pre">pr</span></code> is aligned at a 2-byte boundary; so 1 byte of padding is inserted
between them. So, the whole struct consumes six bytes, aligned at a 2-byte
boundary.</li>
<li>In type <code class="docutils literal notranslate"><span class="pre">coloredPoint2</span></code> the field <code class="docutils literal notranslate"><span class="pre">pt</span></code> is aligned at a 2-byte boundary, but
the type <code class="docutils literal notranslate"><span class="pre">color</span></code> is aligned at a 1-byte boundary. So, no padding is inserted
between them. But, the resulting type must be aligned at a 2-byte boundary,
so 1 byte of padding is inserted after the <code class="docutils literal notranslate"><span class="pre">color</span></code> field—so, the whole
struct consumes six bytes.</li>
</ul>
</div></blockquote>
<p>The 3d compiler emits diagnostics describing the padding it inserts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Adding</span> <span class="n">padding</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Align</span><span class="o">.</span><span class="n">_coloredPoint1</span> <span class="k">for</span> <span class="mi">1</span> <span class="nb">bytes</span> <span class="n">at</span> <span class="p">(</span><span class="n">preceding</span> <span class="n">field</span> <span class="n">Align</span><span class="o">.</span><span class="n">point</span> <span class="n">pt</span><span class="p">;)</span>
<span class="n">Adding</span> <span class="n">padding</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Align</span><span class="o">.</span><span class="n">_coloredPoint2</span> <span class="k">for</span> <span class="mi">1</span> <span class="nb">bytes</span> <span class="n">at</span> <span class="p">(</span><span class="n">end</span> <span class="n">padding</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute can also be adding to casetypes, though the behavior is
more limited:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">aligned</span>
<span class="k">casetype</span> _Value (UINT8 tag) {
    <span class="k">switch</span> (tag) {
        <span class="k">case</span> 0:
            coloredPoint1 cp1;
        <span class="k">case</span> 1:
            coloredPoint2 cp2;
        <span class="k">default</span>:
            <span class="k">struct</span> {
                point pt;
                UINT16 other;
            } cp3;
    }
} Value;
</pre></div>
</div>
<p>Here, we have an aligned “union”. 3d checks that every branch of the union
describes a field with a fixed size. It then inserts padding at the end of each
field whose size is smaller than the maximum-sized field, to make it so that
every field of the union has the same size. As such, the <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute
on a <code class="docutils literal notranslate"><span class="pre">casetype</span></code> allows one to model the layout of a C union.</p>
<p>Note, the <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute is not allowed on typedefs, enums, or other kinds
of 3d declarations.</p>
<div class="section" id="variable-length-types">
<h2>Variable-length Types<a class="headerlink" href="#variable-length-types" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute is also supported on variable-length types, but use it
with care. 3d inserts alignment padding to mimic the behavior of a C compiler;
but C does not support variable-length types! There are many idioms that C
programmers use to model variable-length types, e.g., a zero-length array at the
end of a struct; sometimes a 1-length array; and sometimes and array with no
length at all, using <a class="reference external" href="https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Flexible-Array-Fields.html">C99 flexible array members</a></p>
<p>A rule of thumb for <code class="docutils literal notranslate"><span class="pre">aligned</span></code> on variable-length types is that it only applies
to the fixed-size prefix of the type. For example, consider the following type:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _tlv {
  UINT8 tag;
  UINT32 length;
  UINT8 other;
  Value(tag) payload[:byte-size length];
  UINT32 other2;
} TLV;
</pre></div>
</div>
<p>The output from the 3d compiler includes the following diagnostic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Adding</span> <span class="n">padding</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Align</span><span class="o">.</span><span class="n">_tlv</span> <span class="k">for</span> <span class="mi">3</span> <span class="nb">bytes</span> <span class="n">at</span> <span class="p">(</span><span class="n">preceding</span> <span class="n">field</span> <span class="n">dependent</span> <span class="n">UINT32</span> <span class="n">length</span><span class="p">;)</span>
<span class="n">Adding</span> <span class="n">padding</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Align</span><span class="o">.</span><span class="n">_tlv</span> <span class="k">for</span> <span class="mi">1</span> <span class="nb">bytes</span> <span class="n">at</span> <span class="p">(</span><span class="n">preceding</span> <span class="n">field</span> <span class="n">Align</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="n">payload</span><span class="p">[:</span><span class="n">byte</span><span class="o">-</span><span class="n">size</span> <span class="n">length</span><span class="p">];)</span>
</pre></div>
</div>
<ul class="simple">
<li>3d adds 3 bytes after <code class="docutils literal notranslate"><span class="pre">tag</span></code> and preceding <code class="docutils literal notranslate"><span class="pre">length</span></code>, since <code class="docutils literal notranslate"><span class="pre">length</span></code> is 4-byte
aligned.</li>
<li>It adds 1 byte after <code class="docutils literal notranslate"><span class="pre">other</span></code> and preceding the <code class="docutils literal notranslate"><span class="pre">payload</span></code> field, since the
payload is a <code class="docutils literal notranslate"><span class="pre">Value</span></code> array and is 2-byte aligned.</li>
<li>But, notice, it does not add a padding field after <code class="docutils literal notranslate"><span class="pre">payload</span></code> to align the
<code class="docutils literal notranslate"><span class="pre">other2</span></code> field, since <code class="docutils literal notranslate"><span class="pre">other2</span></code> follows a variable-length field.</li>
</ul>
<p>In contrast, consider the following type in C:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_tlv</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="w">  </span><span class="n">Value</span><span class="w"> </span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">TLV</span><span class="p">;</span>
</pre></div>
</div>
<p>The alignment of the <code class="docutils literal notranslate"><span class="pre">Value</span> <span class="pre">payload[0]</span></code> field is 2, but its size is zero. So,
a C compiler adds the following padding:</p>
<ul class="simple">
<li>3 bytes after <code class="docutils literal notranslate"><span class="pre">tag</span></code> and preceding <code class="docutils literal notranslate"><span class="pre">length</span></code>, since <code class="docutils literal notranslate"><span class="pre">length</span></code> is 4-byte
aligned.</li>
<li>1 byte after <code class="docutils literal notranslate"><span class="pre">other</span></code> and preceding the <code class="docutils literal notranslate"><span class="pre">payload</span></code> field, since the payload
is 2-byte aligned.</li>
<li>2 bytes of end padding, since the alignment of <code class="docutils literal notranslate"><span class="pre">TLV</span></code> is 4</li>
</ul>
<p>In such cases, if one really intends to model a variable-length C type, it is
better to explicitly insert alignment padding to match a given layout, rather
than relying on 3d to insert alignment padding that may not match the layout you
have in mind.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _tlv_alt {
  UINT8 tag;
  UINT8 padding0[3];
  UINT32 length;
  UINT8 other;
  UINT8 padding1;
  Value(tag) payload[:byte-size length];
  UINT16 padding2;
} TLV_ALT;
</pre></div>
</div>
</div>
<div class="section" id="static-assertions-to-validate-alignment">
<h2>Static Assertions to Validate Alignment<a class="headerlink" href="#static-assertions-to-validate-alignment" title="Permalink to this headline">¶</a></h2>
<p>To confirm that the alignment 3d inserts matches the layout of a C type, 3d
automatically generates C types corresponding to every type with an <code class="docutils literal notranslate"><span class="pre">aligned</span></code>
attribute, and emits C static assertions to check that the sizes and field
offsets computed by 3d match what the C compiler computes.</p>
<p>For example, for the types defined in this section, 3d generates a file
<code class="docutils literal notranslate"><span class="pre">AlignAutoStaticAssertions.c</span></code> with the contents below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>


<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">UINT8</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UINT16</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UINT32</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">UINT64</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_point</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT16</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT16</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">point</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_coloredPoint1</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">  </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">coloredPoint1</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_coloredPoint2</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">coloredPoint2</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">_Value</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">coloredPoint1</span><span class="w"> </span><span class="n">cp1_0</span><span class="p">;</span>
<span class="w">  </span><span class="n">coloredPoint2</span><span class="w"> </span><span class="n">cp2_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="w">    </span><span class="n">UINT16</span><span class="w"> </span><span class="n">other</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">cp3_2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_tlv</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT8</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">TLV</span><span class="p">;</span>
<span class="cp">#define EVERPARSE_STATIC_ASSERT(e) typedef char __EVERPARSE_STATIC_ASSERT__[(e)?1:-1];</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TLV</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
</pre></div>
</div>
<p>Notice that in the C transcription of the type <code class="docutils literal notranslate"><span class="pre">TLV</span></code>, 3d simply omits the
suffix of the type starting with the variable-length payload field.</p>
<p>If you compile this file with a C compiler (e.g., <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-c</span>
<span class="pre">AlignAutoStaticAssertions.c</span></code>), you will see that the following static assertion
will fail, an indicator that for this variable-length type, you will be better
off removing the <code class="docutils literal notranslate"><span class="pre">align</span></code> attribute and explicitly modeling the alignment
padding yourself:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TLV</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>This is becase the C compiler inserts 3 bytes of end padding after the field
<code class="docutils literal notranslate"><span class="pre">other</span></code>, whereas with the variable-length field, 3d adds 1 byte of padding.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Arguably, due to these potential discrepancies, 3d could simply forbid the
<code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute on variable-length types.</p>
</div>
</div>
</div>
<div class="section" id="explicitly-checking-3d-types-for-correspondence-with-existing-c-types">
<h1>Explicitly checking 3d types for correspondence with existing C types<a class="headerlink" href="#explicitly-checking-3d-types-for-correspondence-with-existing-c-types" title="Permalink to this headline">¶</a></h1>
<p>In addition to automatically generating static assertions for types with the
<code class="docutils literal notranslate"><span class="pre">aligned</span></code> attribute, 3d allows one to explicitly assert the correspondence
between some 3d typed and C types.</p>
<p>A typical scenario is that you have an existing C program with some collection
of types defined in a file <code class="docutils literal notranslate"><span class="pre">Types.h</span></code>.  You’ve written a <code class="docutils literal notranslate"><span class="pre">Types.3d</span></code> file to
defined validators for byte buffers containing those types, typically <em>refining</em>
the C types with additional semantic constraints and also with actions. Now, you
may want to make sure that types you defined in <code class="docutils literal notranslate"><span class="pre">Types.3d</span></code> correspond to the
types in <code class="docutils literal notranslate"><span class="pre">Types.h</span></code>, e.g., to ensure that you didn’t forget to include a field
in a struct, or that you’ve made explicit in your <code class="docutils literal notranslate"><span class="pre">Types.3d</span></code> the alignment
padding between struct fields that a C compiler is sometimes requires to insert.</p>
<p>To assist with this, 3d provides the following feature:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="c">// SNIPPET_START: GetFieldPtr.T</span>
<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _T(<span class="k">mutable</span> PUINT8* out) {
    UINT8 f1[10];
    UINT8 f2[20]
    {:on-success
        <span class="k">var</span> x = <span class="k">field_ptr</span>;
        *out = x;
        <span class="k">return</span> true;
    };
} T;
<span class="c">// SNIPPET_END: GetFieldPtr.T</span>


<span class="c">// SNIPPET_START: GetFieldPtr.T act$</span>
<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _TAct(<span class="k">mutable</span> PUINT8* out) {
    UINT8 f1[10];
    UINT8 f2[20]
    {:act  <span class="k">var</span> x = <span class="k">field_ptr</span>; *out = x; };
} TAct;
<span class="c">// SNIPPET_END: GetFieldPtr.T act$</span>


<span class="k">refining</span> &quot;GetFieldPtrBase.h&quot; {
   S <span class="k">as</span> T
}
</pre></div>
</div>
<p>Following the type definitions, the <code class="docutils literal notranslate"><span class="pre">refining</span></code> section states that
the type <code class="docutils literal notranslate"><span class="pre">S</span></code> defined in the C header file <code class="docutils literal notranslate"><span class="pre">GetFieldPtrBase.h</span></code> is
refined by the type <code class="docutils literal notranslate"><span class="pre">T</span></code> defined here. As a result of this
declaration, 3d emits a static assertion in the C code of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;GetFieldPtrBase.h&quot;</span>
<span class="n">C_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span>
</pre></div>
</div>
<p>checking that the <code class="docutils literal notranslate"><span class="pre">sizeof(S)</span></code> as computed by the C compiler matches
3d’s computation of the <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>.</p>
<p>In generality, the refining declaration takes the following form:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">refining</span> &quot;I1.h&quot;, ..., &quot;In.h&quot; {
    S1 <span class="k">as</span> T1, ...
    Sm <span class="k">as</span> Tm
}
</pre></div>
</div>
<p>where each <code class="docutils literal notranslate"><span class="pre">Si</span></code> is a type defined in one of the C header files
“I1.h”, …, “In.h”, and the <code class="docutils literal notranslate"><span class="pre">Ti</span></code> are types defined in the current
3d file. In case the types have the same names, one can simply write
<code class="docutils literal notranslate"><span class="pre">T</span></code> instead of <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">as</span> <span class="pre">T</span></code>.</p>
<p>As a second example, let’s revisit the type from the <a class="reference internal" href="#sec-alignment"><span class="std std-ref">alignment section</span></a>, aiming to show that the 3d type corresponds to the C types
defined in the header file <cite>AlignBase.h</cite> shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">point</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_coloredPoint1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">  </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">coloredPoint1</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_coloredPoint2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">coloredPoint2</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">_Value</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">coloredPoint1</span><span class="w"> </span><span class="n">cp1</span><span class="p">;</span>
<span class="w">  </span><span class="n">coloredPoint2</span><span class="w"> </span><span class="n">cp2</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">point</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">cp3</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_tlv</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="w">  </span><span class="n">Value</span><span class="w"> </span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">TLV</span><span class="p">;</span>
</pre></div>
</div>
<p>Let’s also decorate the 3d file with the following refining declaration:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">refining</span> &quot;AlignBase.h&quot; {
   TLV, Value, coloredPoint2, coloredPoint1, point
}
</pre></div>
</div>
<p>The 3d compiler emits the following static assertions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;AlignBase.h&quot;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">UINT8</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UINT16</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UINT32</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">UINT64</span><span class="p">;</span>

<span class="cp">#define EVERPARSE_STATIC_ASSERT(e) typedef char __EVERPARSE_STATIC_ASSERT__[(e)?1:-1];</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TLV</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">TLV</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint2</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">coloredPoint1</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>As before, the <code class="docutils literal notranslate"><span class="pre">sizeof(TLV)==10</span></code> fails, because of differences in alignment
padding with variable-length structures, a good indication to use explicit
alignment padding for variable-length types.</p>
</div>
<div class="section" id="generating-code-with-for-several-compile-time-configurations">
<h1>Generating code with for several compile-time configurations<a class="headerlink" href="#generating-code-with-for-several-compile-time-configurations" title="Permalink to this headline">¶</a></h1>
<p>Sometimes one wants to write a single format specification to
accommodate several compile-time configurations, e.g., to support
multiple architectures. 3D offers some limited support for decorating
a specification with compile-time conditionals familiar to C
programmers, e.g., <code class="docutils literal notranslate"><span class="pre">#if</span></code> and <code class="docutils literal notranslate"><span class="pre">#else</span></code>, and to generate C code
while preserving these C preprocessor directives.</p>
<p>For example, the listing below shows an integer type that can either
be represented using 64 bits (if <code class="docutils literal notranslate"><span class="pre">ARCH64</span></code> is true) or 32 bits.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _INT {
#<span class="k">if</span> ARCH64
   UINT64 x;
#<span class="k">else</span>
   UINT32 x;
#endif   
} INT;


<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _POINT {
   INT x;
   INT y;
} POINT;
</pre></div>
</div>
<p>To compile such a file using 3D, we also need to provide a
<code class="docutils literal notranslate"><span class="pre">.3d.config</span></code> file that declares all the compile-time flags used in
the specification and mentions a C header file in which to find
definitions for those flags. Here is a sample config file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="s2">&quot;compile_time_flags&quot;</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="s2">&quot;flags&quot;</span><span class="p">:[</span><span class="s2">&quot;ARCH64&quot;</span><span class="p">],</span>
      <span class="s2">&quot;include_file&quot;</span><span class="p">:</span><span class="s2">&quot;arch_flags.h&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, one can invoke <code class="docutils literal notranslate"><span class="pre">3d.exe</span> <span class="pre">--config</span> <span class="pre">Arch.3d.config</span>
<span class="pre">PointArch_32_64.3d</span> <span class="pre">--batch</span></code>, which produces the following C code as
output.</p>
<p>In the header file <code class="docutils literal notranslate"><span class="pre">PointArch_32_64.h</span></code>, we see an include for
the header file mentioned in the config:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;arch_flags.h&quot;</span>
</pre></div>
</div>
<p>In the generated C file, <code class="docutils literal notranslate"><span class="pre">PointArch_32_64.c</span></code>, we see the code below,
with the suitable preprocessor directives protecting the two variants
of the the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type declared in the source 3d file.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint64_t</span>
<span class="nf">ValidateInt</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="p">{</span>
<span class="w">   </span><span class="cp">#if ARCH64</span>
<span class="w">   </span><span class="cm">/* Validating field x */</span>
<span class="w">   </span><span class="cm">/* Checking that we have enough space for a UINT64, i.e., 8 bytes */</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="cp">#else</span>
<span class="w">   </span><span class="cm">/* Validating field x */</span>
<span class="w">   </span><span class="cm">/* Checking that we have enough space for a UINT32, i.e., 4 bytes */</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="validating-data-with-indirections-or-pointers">
<h1>Validating Data with Indirections or Pointers<a class="headerlink" href="#validating-data-with-indirections-or-pointers" title="Permalink to this headline">¶</a></h1>
<p>In some cases, rather than parsing from a flat array of contiguous memory, one
wants to parse a structure with indirections, i.e., the input buffer may contain
pointers to other chunks of memory containing sub-structures to be parsed.</p>
<p>Parsing such pointer-rich structures is delicate, since before following a
pointer, one needs to check that the pointer references valid memory. Given a
raw pointer (just a memory address), one cannot, in general, check that the
pointer is valid. However, in some scenarios, such checks are possible, e.g., in
kernel code, it may be possible to probe a pointer to check that it is valid,
and only then proceed to read from it. 3d supports parsing structures containing
pointers, provided safe probing functions can be provided by the caller.</p>
<div class="section" id="pointer-types">
<h2>Pointer Types<a class="headerlink" href="#pointer-types" title="Permalink to this headline">¶</a></h2>
<p>Let’s start by looking at some basic support for pointer types in 3d.</p>
<p>As in C, any field of a structure can be marked as a pointer: here, below, the
second field <code class="docutils literal notranslate"><span class="pre">y</span></code> is marked as pointer to a <code class="docutils literal notranslate"><span class="pre">UINT32</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _TypeWithPointer {
  UINT32 x;
  UINT32 *y;
} TypeWithPointer;
</pre></div>
</div>
<p>By default, a pointer type is simply treated as an unsigned 64-bit integer and
3d will not dereference the pointer when validating a type. One can mark any
field as a pointer, not just fields with base type, and a pointer field can be
associated with a constraint, as any other field of a base type. The example
below shows a constraint on a pointer field checking that it is
non-null—notice that in the constraint,  the <code class="docutils literal notranslate"><span class="pre">ptr</span></code> value is just treated as
having type <code class="docutils literal notranslate"><span class="pre">UINT64</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _NonNullPointer {
  UINT32 len;
  TypeWithPointer *ptr
    { ptr != 0uL };
} NonNullPointer;
</pre></div>
</div>
<p>One can also associate an action with a pointer field, e.g., reading its value
into an out parameter.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _MoreTypesWithPointer(<span class="k">mutable</span> UINT64 *out) {
  UINT32 len;
  TypeWithPointer *ptr 
    {:act *out = ptr;};
} MoreTypesWithPointer;
</pre></div>
</div>
<p>One can also explicitly mark the size of a pointer, giving it the type
<code class="docutils literal notranslate"><span class="pre">UINT64</span></code> (the default) or <code class="docutils literal notranslate"><span class="pre">UINT32</span></code>, as shown in the examples below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _ExplicitPointerSize64(<span class="k">mutable</span> UINT64 *out) {
  UINT32 len;
  TypeWithPointer *<span class="k">pointer</span>(UINT64) ptr 
    { ptr != 0uL }
    {:act *out = ptr;};
} ExplicitPointerSize64;

<span class="k">typedef</span> <span class="k">struct</span> _ExplicitPointerSize32(<span class="k">mutable</span> UINT32 *out) {
  UINT32 len;
  TypeWithPointer *<span class="k">pointer</span>(UINT32) ptr 
    { ptr != 0ul }
    {:act *out = ptr;};
} ExplicitPointerSize32;
</pre></div>
</div>
<p>Note, in all these examples, the <em>type</em> of pointed-to data is irrelevant: 3d
simply treats the pointer as an integer value.</p>
</div>
<div class="section" id="probing-pointers-a-first-example">
<h2>Probing Pointers: A first example<a class="headerlink" href="#probing-pointers-a-first-example" title="Permalink to this headline">¶</a></h2>
<p>We now look at how to traverse pointers, dereferencing them and validating the
data they point to.</p>
<p>Let’s start with a simple example. Our goal is to validate a format that
contains a single indirection: a structure <code class="docutils literal notranslate"><span class="pre">S</span></code> containing a pointer to a
structure <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">probe</span> ProbeAndCopy
<span class="k">extern</span> <span class="k">probe</span> (INIT) ProbeInit

<span class="k">typedef</span> <span class="k">struct</span> _T(UINT32 bound) {
  UINT16 x { x &gt;= bound };
  UINT16 y { y &gt;= x };
} T;

<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _S(EVERPARSE_COPY_BUFFER_T dest) {
  UINT8 bound;
  T(bound) *tpointer <span class="k">probe</span> ProbeAndCopy(length = <span class="k">sizeof</span>(T), destination = dest);
} S;
</pre></div>
</div>
<p>The first line declares a <code class="docutils literal notranslate"><span class="pre">probe</span></code> function called <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code>. This is a
requirement on the user of the generated parser to link the generated code with
a function called <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code>. In fact, the generated code contains an
extern declaration with the signature shown below (in <code class="docutils literal notranslate"><span class="pre">Probe_ExternalAPI.h</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeAndCopy</span><span class="p">(</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">  </span><span class="c1">//The number of bytes to copy</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">read_offset</span><span class="p">,</span><span class="w"> </span><span class="c1">//starting at this offset from the src pointer</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">write_offset</span><span class="p">,</span><span class="w"> </span><span class="c1">//writing to this offset in the dst buffer</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="c1">//the source address to be probed and checked for validity</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="c1">//the target buffer into which the data is to be copied</span>
<span class="p">);</span>
</pre></div>
</div>
<p>That is, the <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> function is expected to check probe the source address,
check its validity at <code class="docutils literal notranslate"><span class="pre">read_offset</span></code>, and copy <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes into the <code class="docutils literal notranslate"><span class="pre">dst</span></code>
buffer starting at <code class="docutils literal notranslate"><span class="pre">write_offset</span></code>.</p>
<p>Note, although a typical implementation may choose to copy memory into the
destination buffer, this not strictly required. In particular, the type
<code class="docutils literal notranslate"><span class="pre">EVERPARSE_COPY_BUFFER_T</span></code> is also left to the user to define. In particular,
in <code class="docutils literal notranslate"><span class="pre">EverParseEndianness.h</span></code>, we have</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="p">;</span>
</pre></div>
</div>
<p>While in <code class="docutils literal notranslate"><span class="pre">EverParse.h</span></code>, we further have:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="nf">EverParseStreamOf</span><span class="p">(</span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">EverParseStreamLen</span><span class="p">(</span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>
</pre></div>
</div>
<p>That is, the client code can choose any definition for
<code class="docutils literal notranslate"><span class="pre">EVERPARSE_COPY_BUFFER_T</span></code> (since it is just a <code class="docutils literal notranslate"><span class="pre">void*</span></code>), so long as it can
also provide two functions: <code class="docutils literal notranslate"><span class="pre">EverParseStreamOf</span></code> to extract a buffer of bytes
from a <code class="docutils literal notranslate"><span class="pre">EVERPARSE_COPY_BUFFER_T</span></code>; and <code class="docutils literal notranslate"><span class="pre">EverParseStreamLen</span></code> to extract the
length of the buffer.</p>
<p>The second line defines another extern callback for <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">probe</span> <span class="pre">(INIT)</span>
<span class="pre">ProbeInit</span></code>. This results in the following extern C declaration in
<code class="docutils literal notranslate"><span class="pre">Probe_ExternalAPI.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="n">ProbeInit</span><span class="p">(</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">dst</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ProbeInit</span></code> callback allows a caller to initialize the destination buffer,
preparing it to contain up to <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of data, e.g., if need be, one
could use this callback to allocate memory.</p>
<p>Let’s return to the example to see how the <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> function is used.</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">T</span></code> is just a struct with two fields, constrained by a lower bound.
The type <code class="docutils literal notranslate"><span class="pre">S</span></code> is more interesting. It starts with a <code class="docutils literal notranslate"><span class="pre">UINT8</span> <span class="pre">bound</span></code> and then
contains a <em>pointer</em> <code class="docutils literal notranslate"><span class="pre">t</span></code> to a <code class="docutils literal notranslate"><span class="pre">T`(bound)</span></code> struct. To emphasize the point,
the following picture illustrates the layout:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="nb">bytes</span>
    <span class="mf">0.</span><span class="o">......</span><span class="mf">.1</span><span class="o">.......</span><span class="mf">.2</span><span class="o">.......</span><span class="mf">.3</span><span class="o">.......</span><span class="mf">.4</span><span class="o">.......</span><span class="mf">.5</span><span class="o">.......</span><span class="mf">.6</span><span class="o">.......</span><span class="mf">.7</span><span class="o">.......</span><span class="mf">.8</span><span class="o">.......</span><span class="mf">.9</span>
<span class="n">S</span><span class="p">:</span>  <span class="p">{</span> <span class="n">bound</span>  <span class="o">|</span>              <span class="n">tpointer</span>                                                 <span class="p">}</span>
                               <span class="o">|</span>
                               <span class="o">|</span>
     <span class="o">.-------------------------.</span>
     <span class="o">|</span>
     <span class="n">v</span>
    <span class="mf">0.</span><span class="o">......</span><span class="mf">.1</span><span class="o">.......</span><span class="mf">.2</span><span class="o">.......</span><span class="mf">.3</span><span class="o">.......</span><span class="mf">.4</span><span class="o">.......</span><span class="mf">.5</span><span class="o">.......</span><span class="mf">.6</span><span class="o">.......</span><span class="mf">.7</span><span class="o">.......</span><span class="mf">.8</span><span class="o">........</span><span class="mf">.9</span>
<span class="n">T</span><span class="p">:</span>  <span class="p">{</span>        <span class="n">x</span>        <span class="o">|</span>        <span class="n">y</span>        <span class="p">}</span>
</pre></div>
</div>
<p>The input buffer represents the <code class="docutils literal notranslate"><span class="pre">S</span></code> structure in 5 bytes, beginning with one
byte for the <code class="docutils literal notranslate"><span class="pre">bound</span></code>, and following by 8 bytes for the <code class="docutils literal notranslate"><span class="pre">tpointer</span></code>
field—currently, 3D treats pointer fields as always 8 bytes long.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tpointer</span></code> field contains a memory address that points to the a <code class="docutils literal notranslate"><span class="pre">T</span></code>
structure, which is represented in 4 bytes, with 2 bytes each for its <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> fields, as usual.</p>
<p>The 3D notation below:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>T(bound) *tpointer <span class="k">probe</span> ProbeAndCopy(length = <span class="k">sizeof</span>(T), destination = dest);
</pre></div>
</div>
<p>Instructs the parser to:</p>
<blockquote>
<div><ul class="simple">
<li>First, read the contents of the <code class="docutils literal notranslate"><span class="pre">tpointer</span></code> field into a local vairable <code class="docutils literal notranslate"><span class="pre">src</span></code></li>
<li>Then, call <code class="docutils literal notranslate"><span class="pre">ProbeInit(4,</span> <span class="pre">dest)</span></code> to prepare the destination buffer, where
<code class="docutils literal notranslate"><span class="pre">sizeof(T)=4</span></code>.</li>
<li>Then, if <code class="docutils literal notranslate"><span class="pre">ProbeInit</span></code> succeeds, use <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy(sizeof(T),</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">src,</span>
<span class="pre">destS)</span></code> check that the <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code> bytes starting at the address pointed
to by <code class="docutils literal notranslate"><span class="pre">tpointer</span></code> is valid memory, using the <code class="docutils literal notranslate"><span class="pre">dest</span></code> parameter as its copy
buffer.</li>
<li>Finally, if <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> succeeds, then validate that
<code class="docutils literal notranslate"><span class="pre">EverParseStreamOf(dest)</span></code> buffer contains a valid <code class="docutils literal notranslate"><span class="pre">T(bound)</span></code> structure,
in <code class="docutils literal notranslate"><span class="pre">EverParseStreamLen(dest)</span></code> bytes.</li>
</ul>
</div></blockquote>
<p>Ultimately, the generated code provides the following signature for a C caller,
in <code class="docutils literal notranslate"><span class="pre">ProbeWrapper.h</span></code>, to validate a buffer pointers to by <code class="docutils literal notranslate"><span class="pre">base</span></code>, containing
at least <code class="docutils literal notranslate"><span class="pre">len</span></code> bytes, checking that it contains a valid <code class="docutils literal notranslate"><span class="pre">S(dest)</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeCheckS</span><span class="p">(</span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="probing-multiple-indirections">
<h2>Probing Multiple Indirections<a class="headerlink" href="#probing-multiple-indirections" title="Permalink to this headline">¶</a></h2>
<p>Continuing our simple example, let’s add another layer of indirection:, with a
structure <code class="docutils literal notranslate"><span class="pre">U</span></code> containing a pointer to <code class="docutils literal notranslate"><span class="pre">S</span></code>. This can be specified as shown
below:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _U(EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
  UINT8 tag;
  S(destT) *spointer <span class="k">probe</span> ProbeAndCopy(length = <span class="k">sizeof</span>(S), destination = destS);
} U;
</pre></div>
</div>
<ul class="simple">
<li>The type <code class="docutils literal notranslate"><span class="pre">U</span></code> packages a pointer to an <code class="docutils literal notranslate"><span class="pre">S</span></code> structure with a tag.</li>
<li>The specification of <code class="docutils literal notranslate"><span class="pre">U</span></code> is parameterized by <cite>two</cite> destintation buffers:
<code class="docutils literal notranslate"><span class="pre">destS</span></code> to receive the contents of the memory referenced by <code class="docutils literal notranslate"><span class="pre">spointer</span></code>;
and <code class="docutils literal notranslate"><span class="pre">destT</span></code> to receive the contents of the memory referenced by
<code class="docutils literal notranslate"><span class="pre">tpointer</span></code>.</li>
</ul>
<p>Operationally, the validator for <code class="docutils literal notranslate"><span class="pre">U</span></code> proceeds by:</p>
<ul class="simple">
<li>First, validating the tag field (in this case, it is a noop)</li>
<li>Then, reading <code class="docutils literal notranslate"><span class="pre">spointer</span></code> into <code class="docutils literal notranslate"><span class="pre">srcS</span></code> and<ul>
<li>Calling <code class="docutils literal notranslate"><span class="pre">ProbeInit(sizeof(S),</span> <span class="pre">destS)</span></code></li>
<li>Then, <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy(sizeof(S),</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">srcS,</span> <span class="pre">destS)</span></code></li>
<li>Then, validate <code class="docutils literal notranslate"><span class="pre">EverParseStreamOf(destS)</span></code> contains a valid <code class="docutils literal notranslate"><span class="pre">S(destT)</span></code>.</li>
</ul>
</li>
</ul>
<p>The validation of <code class="docutils literal notranslate"><span class="pre">S(destT)</span></code> proceeds as described before, copying the
contents of <code class="docutils literal notranslate"><span class="pre">tpointer</span></code> into <code class="docutils literal notranslate"><span class="pre">destT</span></code> and validating it.</p>
<p>The C interface includes the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeCheckU</span><span class="p">(</span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destS</span><span class="p">,</span><span class="w"> </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>Note, one can also reuse the same copy buffer for multiple probe, so long as the
probes are done sequentially. For instance, we use several probes below, reusing
<code class="docutils literal notranslate"><span class="pre">destT</span></code> multiple times to parser the nested <code class="docutils literal notranslate"><span class="pre">T</span></code> structure within <code class="docutils literal notranslate"><span class="pre">sptr</span></code>,
and again for <code class="docutils literal notranslate"><span class="pre">tptr</span></code> and <code class="docutils literal notranslate"><span class="pre">t2ptr</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _V(EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
  UINT8 tag;
  S(destT) *sptr <span class="k">probe</span> ProbeAndCopy(length = 9, destination = destS);
  T(17) *tptr <span class="k">probe</span> ProbeAndCopy(length = 8, destination = destT);
  T(tag) *t2ptr <span class="k">probe</span> ProbeAndCopy(length = 8, destination = destT);
} V;
</pre></div>
</div>
<p>This is allowed since the probes are done sequentially, and the copy buffer is
not reused before the probe &amp; validation are complete. On the other hand, if
one were to try to reuse a copy buffer before its probe &amp; validation are
complete (e.g., by using <code class="docutils literal notranslate"><span class="pre">destT</span></code> as the destination buffer for <code class="docutils literal notranslate"><span class="pre">sptr</span></code>) 3D
issues an error message:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">Probe</span><span class="mf">.3</span><span class="n">d</span><span class="p">:(</span><span class="mi">30</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span> <span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="n">Nested</span> <span class="n">mutation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">copy</span> <span class="n">buffer</span> <span class="p">[</span><span class="n">destT</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="top-level-probes">
<h2>Top-level Probes<a class="headerlink" href="#top-level-probes" title="Permalink to this headline">¶</a></h2>
<p>Rather than attaching a probe to a field, one can also attach a probe to an
entire type. For instance, one can write the following:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span> <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(<span class="k">this</span>))
<span class="k">typedef</span> <span class="k">struct</span> _Indirect {
  UINT32 fst;
  UINT32 snd;
  UINT8 tag;
} Indirect;
</pre></div>
</div>
<p>This type specifies the following layout, with an input buffer containing a
single pointer which refers to a buffer containing a valid struct with three
fields.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="nb">bytes</span>
   <span class="mf">0.</span><span class="o">......</span><span class="mf">.1</span><span class="o">.......</span><span class="mf">.2</span><span class="o">.......</span><span class="mf">.3</span><span class="o">.......</span><span class="mf">.4</span><span class="o">.......</span><span class="mf">.5</span><span class="o">.......</span><span class="mf">.6</span><span class="o">.......</span><span class="mf">.7</span><span class="o">.......</span><span class="mf">.8</span>
 <span class="n">I</span><span class="p">:{</span>                        <span class="n">pointer</span>                                        <span class="p">}</span>
                              <span class="o">|</span>
                              <span class="o">|</span>
    <span class="o">.-------------------------.</span>
    <span class="o">|</span>
    <span class="n">v</span>
   <span class="mf">0.</span><span class="o">......</span><span class="mf">.1</span><span class="o">.......</span><span class="mf">.2</span><span class="o">.......</span><span class="mf">.3</span><span class="o">.......</span><span class="mf">.4</span><span class="o">.......</span><span class="mf">.5</span><span class="o">.......</span><span class="mf">.6</span><span class="o">.......</span><span class="mf">.7</span><span class="o">.......</span><span class="mf">.8</span><span class="o">........</span><span class="mf">.9</span>
<span class="n">TT</span><span class="p">:{</span>        <span class="n">x</span>                          <span class="o">|</span>                 <span class="n">y</span>                 <span class="o">|</span>   <span class="n">tag</span>    <span class="p">}</span>
</pre></div>
</div>
<p>This yields the following C interface, with two entry points. The first is to
probe and validate a pointer to the type <code class="docutils literal notranslate"><span class="pre">Indirect</span></code>, while the second is to
validate a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Indirect</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeProbeAndCopyCheckIndirect</span><span class="p">(</span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">probeDest</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">probeAddr</span><span class="p">);</span>
<span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeCheckIndirect</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>The specification is equivalent to the following, though more concise:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _TT {
  UINT32 fst;
  UINT32 snd;
  UINT8 tag;
} TT;

<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _I(EVERPARSE_COPY_BUFFER_T dest) {
  TT *ttptr <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(TT), destination=dest);
} I;
</pre></div>
</div>
</div>
<div class="section" id="coercing-pointer-types">
<span id="coercing-pointers"></span><h2>Coercing Pointer Types<a class="headerlink" href="#coercing-pointer-types" title="Permalink to this headline">¶</a></h2>
<p>One can also add a probe to a pointer with an explicit pointer size, so long as
one also provides a callback to convert a value from that explicit pointer size
to <code class="docutils literal notranslate"><span class="pre">UINT64</span></code>, as in the example below:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">PURE</span> UINT64 UlongToPtr(UINT32 ptr)
<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _CoercePtr(EVERPARSE_COPY_BUFFER_T dest) {
  UINT32 Bound;
  T(Bound) *<span class="k">pointer</span>(UINT32) ptr <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=dest);
} CoercePtr;
</pre></div>
</div>
<p>Here, we first define a callback <code class="docutils literal notranslate"><span class="pre">UlongToPtr</span></code> to convert a <code class="docutils literal notranslate"><span class="pre">UINT32</span></code> to a
<code class="docutils literal notranslate"><span class="pre">UINT64</span></code>.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Probe_ExternalAPI.h</span></code>, this extern declaration produces the following C
signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">UlongToPtr</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, in <code class="docutils literal notranslate"><span class="pre">CoercePtr</span></code>, we can qualify our pointer type to 32-bits: the 3d
compiler will automatically insert the <code class="docutils literal notranslate"><span class="pre">UlongToPtr</span></code> coercion on the 32-bit
pointer value before called <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> with the coerced pointer value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you declare more than one coercion to coerce between a pair of types, 3d
will likely complain with the following error:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>./Probe.3d:(132,33): (Error) Multiple extern coercions found for UINT32 -&gt; UINT64: Probe.UlongToPtr, Probe.UlongToPtr2
</pre></div>
</div>
<p class="last">This is because 3d applies coercions implicitly, and if multiple coercions are
found between a pair of types, it cannot choose which coercion to apply.</p>
</div>
</div>
<div class="section" id="multiple-probe-callbacks">
<h2>Multiple Probe Callbacks<a class="headerlink" href="#multiple-probe-callbacks" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, it can be useful to have several probe callbacks, e.g., some of them
may copy, while for others it might be safe to validate the data in place.</p>
<p>The example below shows how to use multiple probes:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">probe</span> ProbeAndCopyAlt

<span class="k">entrypoint</span> <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(<span class="k">this</span>))
<span class="k">entrypoint</span> <span class="k">probe</span> ProbeAndCopyAlt(length=<span class="k">sizeof</span>(<span class="k">this</span>))
<span class="k">typedef</span> <span class="k">struct</span> _MultiProbe(EVERPARSE_COPY_BUFFER_T destT1, EVERPARSE_COPY_BUFFER_T destT2) {
  UINT32 fst;
  UINT32 snd;
  UINT8 tag;
  T(17) *tptr1 <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=destT1);
  T(42) *tptr2 <span class="k">probe</span> ProbeAndCopyAlt(length=<span class="k">sizeof</span>(T), destination=destT2);
} MultiProbe;
</pre></div>
</div>
<ul class="simple">
<li>The extern declaration of <code class="docutils literal notranslate"><span class="pre">ProbeAndCopyAlt</span></code> produces a second extern
declaration in <code class="docutils literal notranslate"><span class="pre">Probe_ExternalAPI.h</span></code> for the client code to provide and link
with.</li>
<li>One can associate multiple entrypoint probe attributes on a type, each with a
different probe and copy function.</li>
<li>One can also associate different probes on each field of a type.</li>
</ul>
<p>The resulting C interface contains multiple entry points, one for each variant
of probing entry point, and one for the non-probing variant:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeProbeAndCopyCheckMultiProbe</span><span class="p">(</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT1</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT2</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">probeDest</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">probeAddr</span><span class="p">);</span>

<span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeProbeAndCopyAltCheckMultiProbe</span><span class="p">(</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT1</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT2</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">probeDest</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">probeAddr</span><span class="p">);</span>

<span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ProbeCheckMultiProbe</span><span class="p">(</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT1</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destT2</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>External declarations for probe callbacks and for pointer coercions are in
scope for the entire file, since 3d can call these functions implicitly when
elaborating a specification. So, unless you are an expert and have a
particular need for multiple probe callbacks, it is possible that declaring
multiple probe callbacks can result in errors such as the one below,
especially when using multiple probe callbacks in conjuction with
<a class="reference internal" href="#specialization"><span class="std std-ref">specialization</span></a>.</p>
<div class="last highlight-text notranslate"><div class="highlight"><pre><span></span>./Specialize1.3d:(10,30): (Error) Found multiple probe functions: Specialize1.ProbeAndCopyAlt, Specialize1.ProbeAndCopy
</pre></div>
</div>
</div>
</div>
<div class="section" id="nullable-pointers">
<h2>Nullable Pointers<a class="headerlink" href="#nullable-pointers" title="Permalink to this headline">¶</a></h2>
<p>By default, all probed pointer fields are expected to be non-null. If a pointer
value happens to be null, then either</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> function can return false, in which case validation fails</li>
<li>Or, the <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy</span></code> function can return true, in which the generated code
would proceed to try to validate the contents of the destination buffer, which
will likely fail.</li>
</ul>
<p>If a pointer in a data structure is allowed to be null, then one can mark it as
such with a nullable qualifier, <code class="docutils literal notranslate"><span class="pre">pointer?</span></code> as shown below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _MaybeT(EVERPARSE_COPY_BUFFER_T dest) {
  UINT32 Bound;
  T(Bound) *<span class="k">pointer</span>? ptr <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=dest);
} MaybeT;
</pre></div>
</div>
<p>For a pointer with a nullable qualifier, the generated code first checks if the
pointer is non-null:</p>
<ul class="simple">
<li>If the pointer is null, validation succeeds without calling the probe function</li>
<li>If the pointer is non-null, the probe function is called, and validation
proceeds as in the non-null case.</li>
</ul>
</div>
<div class="section" id="an-end-to-end-executable-example">
<h2>An End-to-end Executable Example<a class="headerlink" href="#an-end-to-end-executable-example" title="Permalink to this headline">¶</a></h2>
<p>A small but fully worked out example <a class="reference external" href="https://github.com/project-everest/everparse/tree/master/src/3d/tests/probe">is available in the EverParse repository</a>.</p>
<p>It shows the use of multiple probe functions, linked with callbacks implemented
in C, as well as a main C driver program that validates several example inputs
containing pointers.</p>
</div>
</div>
<div class="section" id="specialization-for-different-pointer-sizes">
<span id="specialization"></span><h1>Specialization for Different Pointer Sizes<a class="headerlink" href="#specialization-for-different-pointer-sizes" title="Permalink to this headline">¶</a></h1>
<p>Consider writing a specification to handle messages that could be sent from both
32- and 64-bit machines, particularly if those messages contain pointers. This
scenario happens in practice, e.g., when a 64-bit OS kernel shares memory with
user-mode processes that may be either native 64-bit processes or emulated
32-bit processes.</p>
<p>3d supports a form of compile-time specialization that allows one to write a
specification with 64-bit clients in mind, and then have the compiler specialize
the 64-bit specification also for use with a 32-bit clients. There are many
subtle elements to consider, and we describe them gradually, starting with a
simple first example.</p>
<div class="section" id="a-first-example">
<h2>A First Example<a class="headerlink" href="#a-first-example" title="Permalink to this headline">¶</a></h2>
<p>As in the previous section, we have a format with two levels of indirection:
<code class="docutils literal notranslate"><span class="pre">R64</span></code> with a pointer to <code class="docutils literal notranslate"><span class="pre">S64</span></code>, and <code class="docutils literal notranslate"><span class="pre">S64</span></code> with a pointer to <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">probe</span> ProbeAndCopy
<span class="k">extern</span> <span class="k">probe</span> (INIT) ProbeInit

<span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _T(UINT32 bound) {
    UINT32 t1;
    UINT32 t2 { t2 &lt;= bound };    
} T;

<span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _S64(UINT32 bound, EVERPARSE_COPY_BUFFER_T dest) {
    UINT32 s1 { s1 &lt;= bound };
    T(s1) *ptrT <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=dest);
    UINT32 s2;
} S64;

<span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _R64(EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
    UINT32 r1;
    S64(r1, destT) *ptrS <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(S64), destination=destS);
} R64;
</pre></div>
</div>
<div class="section" id="a-first-manual-attempt">
<h3>A First Manual Attempt<a class="headerlink" href="#a-first-manual-attempt" title="Permalink to this headline">¶</a></h3>
<p>If we wanted to specify a variant of <code class="docutils literal notranslate"><span class="pre">R32</span></code> with a 32-bit pointer to a <code class="docutils literal notranslate"><span class="pre">S32</span></code>
which in turn had a 32-bit pointer to a <code class="docutils literal notranslate"><span class="pre">T</span></code>, we could explicitly rewrite our
entire specification, as shown below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _S32_Attempt(UINT32 bound, EVERPARSE_COPY_BUFFER_T dest) {
    UINT32 f { f &lt;= bound };
    T(f) *<span class="k">pointer</span>(UINT32) ptrT <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=dest);
    UINT32 g;
} S32Attempt;

<span class="k">aligned</span>
<span class="k">typedef</span> <span class="k">struct</span> _R32_Attempt(EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
    UINT32 f;
    S32Attempt(f, destT) *<span class="k">pointer</span>(UINT32) ptrS <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(S32Attempt), destination=destS);
} R32_Attempt;

<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _RMux(Bool requestor32, EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
    <span class="k">switch</span> (requestor32) {
        <span class="k">case</span> true: R32_Attempt(destS, destT) r32;
        <span class="k">default</span>: R64(destS, destT) r64;
    } field;
} RMux;
</pre></div>
</div>
<p>At the top-level of the specification, one could then define <code class="docutils literal notranslate"><span class="pre">RMux</span></code>, a
multiplexing layer, which depending on the value of <code class="docutils literal notranslate"><span class="pre">requestor32</span></code>, validates
either an <code class="docutils literal notranslate"><span class="pre">R32_Attempt</span></code> or an <code class="docutils literal notranslate"><span class="pre">R64</span></code>.</p>
<p>This looks plausible, even though it is verbose and leads to a lot of
duplication. However, even aside from the verbosity this revised specification
has a deeper problem.</p>
<p>Consider the case where <code class="docutils literal notranslate"><span class="pre">requestor32=true</span></code>: if the probe on <code class="docutils literal notranslate"><span class="pre">ptrS</span></code> runs
successfully, it will have copied <code class="docutils literal notranslate"><span class="pre">sizeof(S32Attempt)=12</span></code> bytes, and then
checked that the bytes copied into <code class="docutils literal notranslate"><span class="pre">destS</span></code> is a valid <code class="docutils literal notranslate"><span class="pre">S32Attempt</span></code>. If after
this validation, a caller wants to, say, read the value of the <code class="docutils literal notranslate"><span class="pre">s2</span></code> field,
then they would need to read <code class="docutils literal notranslate"><span class="pre">4</span></code> bytes at offset <code class="docutils literal notranslate"><span class="pre">8</span></code> from <code class="docutils literal notranslate"><span class="pre">destS</span></code> buffer.</p>
<p>On the other hand, when <code class="docutils literal notranslate"><span class="pre">requestor32=false</span></code>: if the probe on <code class="docutils literal notranslate"><span class="pre">ptrS</span></code> runs
successfully, it will have copied <code class="docutils literal notranslate"><span class="pre">sizeof(S64)=24</span></code> bytes (including the 4
bytes of padding between <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">ptrT</span></code> and then 4 bytes of padding after
the field <code class="docutils literal notranslate"><span class="pre">s2</span></code>), and then checked that the bytes copied into <code class="docutils literal notranslate"><span class="pre">destS</span></code> is a
valid <code class="docutils literal notranslate"><span class="pre">S64</span></code>. If after this validation, a caller wants to read the value of the
<code class="docutils literal notranslate"><span class="pre">s2</span></code> field, then they would need to read <code class="docutils literal notranslate"><span class="pre">4</span></code> bytes at offset <code class="docutils literal notranslate"><span class="pre">16</span></code> from
<code class="docutils literal notranslate"><span class="pre">destS</span></code> buffer.</p>
<p>That is, even after reading and validating the input, the caller has to
distinguish the cases of <code class="docutils literal notranslate"><span class="pre">requestor32</span></code>. We would prefer instead to have a way
to handle either 32- or 64-bit inputs, but after validation, we would like the
contents of the destination buffers to always be in 64-bit form, for easy
manipulation by native 64-bit kernel code, without needing to bifurcate further
handling of 32- and 64-bit inputs.</p>
</div>
<div class="section" id="a-second-manual-attempt">
<h3>A Second Manual Attempt<a class="headerlink" href="#a-second-manual-attempt" title="Permalink to this headline">¶</a></h3>
<p>Here’s another attempt at specializing <code class="docutils literal notranslate"><span class="pre">R64</span></code>:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _R32Manual(UINT32 bound, EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
    UINT32 r1 { r1 &lt;= bound };
    S64(r1, destT) *<span class="k">pointer</span>(UINT32) ptrS <span class="k">probe</span> 
        (length=<span class="k">sizeof</span>(S64), destination=destS) {
            ProbeAndCopy(4); <span class="c">//copy field s1</span>
            SkipWrite(4); <span class="c">//4 bytes padding</span>
            <span class="k">var</span> ptrT = ProbeAndReadU32(); <span class="c">//read ptrT</span>
            <span class="k">var</span> ptrT64 = UlongToPtr(ptrT); <span class="c">//write (uint64_t)ptrT</span>
            WriteU64(ptrT64); <span class="c">//write ptrT64</span>
            ProbeAndCopy(4); <span class="c">//copy field s2</span>
            SkipWrite(4); <span class="c">//padding</span>
        };
} R32Manual;
</pre></div>
</div>
<p>This time, we have an even more verbose specification, but we’ll see that it
actually achieves what we want. This specification is legal 3d, and it uses an
explicit, low-level form of probing functions that we do not typically expect
users to write. But, it’s a useful intermediate language to explain things.</p>
<p>The first field, <code class="docutils literal notranslate"><span class="pre">r1</span></code>, is as before.</p>
<p>The second field is an explicitly qualified pointer, qualified to
<code class="docutils literal notranslate"><span class="pre">pointer(UINT32)</span></code> and with probe block associated with it. Our goal is to
coerce probe the input pointer <code class="docutils literal notranslate"><span class="pre">ptrS</span></code> and read its contents while coercing it
into a 64-bit layout, and then to validate that the copied bytes is a valid
<code class="docutils literal notranslate"><span class="pre">S64(r1,</span> <span class="pre">destT)</span></code>.</p>
<p>The probe block will first call <code class="docutils literal notranslate"><span class="pre">ProbeInit</span></code>, initializing the <code class="docutils literal notranslate"><span class="pre">destS</span></code>
buffer, preparing it to receive <code class="docutils literal notranslate"><span class="pre">sizeof(S64)</span></code> bytes. Then, within the probe
block, it executes a sequence of actions:</p>
<ul class="simple">
<li>Copy the first 4 bytes referenced by <code class="docutils literal notranslate"><span class="pre">ptrS</span></code>–this is the <code class="docutils literal notranslate"><span class="pre">s1</span></code> field</li>
<li>Skip 4 bytes of alignment padding</li>
<li>Then read a 32 bit pointer <code class="docutils literal notranslate"><span class="pre">ptrT</span></code>, coerce it to 64-bytes, and write it into
the destination buffer</li>
<li>Then copy the next 4 bytes from the input buffer (field <code class="docutils literal notranslate"><span class="pre">s2</span></code>)</li>
<li>Finally, skip 4 bytes of padding at the end</li>
</ul>
<p>After the probe block executes, we validate the <code class="docutils literal notranslate"><span class="pre">EverParseStreamOf(destS)</span></code> to
contain a valid  <code class="docutils literal notranslate"><span class="pre">S64(r1,</span> <span class="pre">destT)</span></code>, which in turn will probe <code class="docutils literal notranslate"><span class="pre">ptrT</span></code> etc.</p>
<p>This does what we want, in the sense that if validation succeeds, then <code class="docutils literal notranslate"><span class="pre">destS</span></code>
contains a 64-bit representation of the input, regardless of <code class="docutils literal notranslate"><span class="pre">requestor32</span></code>,
and the caller can then proceed uniformly, without needing to bifurcate its
handling of 32- and 64-bit clients.</p>
<p>However, writing low-level coercions like this is impractical and error prone.</p>
</div>
<div class="section" id="automated-specialization">
<h3>Automated Specialization<a class="headerlink" href="#automated-specialization" title="Permalink to this headline">¶</a></h3>
<p>Instead, 3d offers a <code class="docutils literal notranslate"><span class="pre">specialize</span></code> directive, to automatically rewrite a tree
of definitions rooted at a given type, replacing each occurrence of an
<em>unqualified</em> pointer type with an <code class="docutils literal notranslate"><span class="pre">pointer(UINT32)</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) R64 R32;
</pre></div>
</div>
<p>This instructs 3d to automatically generate the definition for <code class="docutils literal notranslate"><span class="pre">R32</span></code> from
<code class="docutils literal notranslate"><span class="pre">R64</span></code>, in the style of <code class="docutils literal notranslate"><span class="pre">R32Manual</span></code>. In doing so, 3d will also try to
specialize the probe function on the nested <code class="docutils literal notranslate"><span class="pre">ptrT</span></code> in the <code class="docutils literal notranslate"><span class="pre">S64</span></code>, but in
doing so it will discover that there is nothing to specialize in <code class="docutils literal notranslate"><span class="pre">T</span></code> and the
behavior of probing <code class="docutils literal notranslate"><span class="pre">ptrT</span></code> will be unchanged.</p>
<p>In order to use the specialize directive, we need to define a few additional
callbacks.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) R64 R32;
</pre></div>
</div>
<p>The first callback, a <code class="docutils literal notranslate"><span class="pre">UlongToPtr</span></code> coercion, we saw <a class="reference internal" href="#coercing-pointers"><span class="std std-ref">before</span></a>: we’ll need it to coerce a 32-bit pointer to 64-bits. It
produces the following C signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">UlongToPtr</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>The next callback, <code class="docutils literal notranslate"><span class="pre">ProbeAndReadU32</span></code> produces the following C signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ProbeAndReadU32</span><span class="p">(</span>
<span class="w">  </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="o">*</span><span class="n">failed</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">read_offset</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">src</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">dest</span><span class="p">);</span>
</pre></div>
</div>
<p>It probes a pointer <code class="docutils literal notranslate"><span class="pre">src</span></code> at a given <code class="docutils literal notranslate"><span class="pre">read_offset</span></code>, checks its validity, and
reads 4 bytes from that offset and returns it as a <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>. If the validity
check fails, it must set its out parameter <code class="docutils literal notranslate"><span class="pre">failed</span></code> to true. It typically does
not use its last parameter <code class="docutils literal notranslate"><span class="pre">dest</span></code>, though this can be used by the caller to
provide useful contextual information.</p>
<p>Finally, the  callback <code class="docutils literal notranslate"><span class="pre">WriteU64</span></code> produces the following C signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">WriteU64</span><span class="p">(</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">write_offset</span><span class="p">,</span>
<span class="w">  </span><span class="n">EVERPARSE_COPY_BUFFER_T</span><span class="w"> </span><span class="n">destination</span><span class="p">);</span>
</pre></div>
</div>
<p>It allows writing a single <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> <code class="docutils literal notranslate"><span class="pre">value</span></code> at a given <code class="docutils literal notranslate"><span class="pre">write_offset</span></code>
into a destination buffer <code class="docutils literal notranslate"><span class="pre">EVERPARSE_COPY_BUFFER_T</span></code>. If the write fails, e.g.,
because <code class="docutils literal notranslate"><span class="pre">write_offset</span></code> is out of bounds, then it must return <code class="docutils literal notranslate"><span class="pre">false</span></code>,
otherwise <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">R32</span></code> now automatically defined, we can easily define our multiplexing
layer, as shown below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> R(Bool requestor32, EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
    <span class="k">switch</span> (requestor32) {
        <span class="k">case</span> true: R32(destS, destT) r32;
        <span class="k">default</span>: R64(destS, destT) r64;
    } field;
} R;
</pre></div>
</div>
</div>
<div class="section" id="first-example-in-its-entirety">
<h3>First Example in its Entirety<a class="headerlink" href="#first-example-in-its-entirety" title="Permalink to this headline">¶</a></h3>
<p>We’ve gone through several iterations to arrive at our first example of
specialization. Here is the final specification in its entirety:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>  <span class="k">extern</span> <span class="k">probe</span> ProbeAndCopy
  <span class="k">extern</span> <span class="k">probe</span> (INIT) ProbeInit
  <span class="k">extern</span> <span class="k">PURE</span> UINT64 UlongToPtr(UINT32 ptr)
  <span class="k">extern</span> <span class="k">probe</span> (READ UINT32) ProbeAndReadU32
  <span class="k">extern</span> <span class="k">probe</span> (WRITE UINT32) WriteU32
  <span class="k">extern</span> <span class="k">probe</span> (WRITE UINT64) WriteU64

  <span class="k">aligned</span>
  <span class="k">typedef</span> <span class="k">struct</span> _T(UINT32 bound) {
      UINT32 t1;
      UINT32 t2 { t2 &lt;= bound };    
  } T;

  <span class="k">aligned</span>
  <span class="k">typedef</span> <span class="k">struct</span> _S64(UINT32 bound, EVERPARSE_COPY_BUFFER_T dest) {
      UINT32 s1 { s1 &lt;= bound };
      T(s1) *ptrT <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(T), destination=dest);
      UINT32 s2;
  } S64;

  <span class="k">aligned</span>
  <span class="k">typedef</span> <span class="k">struct</span> _R64(EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
      UINT32 r1;
      S64(r1, destT) *ptrS <span class="k">probe</span> ProbeAndCopy(length=<span class="k">sizeof</span>(S64), destination=destS);
  } R64;

  <span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) R64 R32;

  <span class="k">entrypoint</span>
  <span class="k">typedef</span> <span class="k">struct</span> R(Bool requestor32, EVERPARSE_COPY_BUFFER_T destS, EVERPARSE_COPY_BUFFER_T destT) {
      <span class="k">switch</span> (requestor32) {
          <span class="k">case</span> true: R32(destS, destT) r32;
          <span class="k">default</span>: R64(destS, destT) r64;
      } field;
  } R;
</pre></div>
</div>
</div>
<div class="section" id="what-is-proven-about-specialization">
<h3>What is Proven About Specialization<a class="headerlink" href="#what-is-proven-about-specialization" title="Permalink to this headline">¶</a></h3>
<p><strong>Safety</strong></p>
<p>As with all code produced by 3d, we prove that the generated code is:</p>
<ul class="simple">
<li>memory safe</li>
<li>arithmetically safe</li>
<li>has no undefined behaviors</li>
<li>is double-fetch free</li>
</ul>
<p>For specifications with probes, these guarantees are, of course, conditional on
the behavior of the extern callbacks. In particular, the callbacks implemnted in
C must themselves be memory safe, e.g., <code class="docutils literal notranslate"><span class="pre">ProbeAndCopy(n,</span> <span class="pre">rd,</span> <span class="pre">wr,</span> <span class="pre">src,</span> <span class="pre">dest)</span></code>
must safely check that <code class="docutils literal notranslate"><span class="pre">src</span> <span class="pre">+</span> <span class="pre">rd</span></code> points to <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes of valid memory and
that safely copies those <code class="docutils literal notranslate"><span class="pre">n</span></code> bytes into <code class="docutils literal notranslate"><span class="pre">dest</span></code> at offset <code class="docutils literal notranslate"><span class="pre">wr</span></code> is safe.</p>
<p><strong>Soundness</strong></p>
<p>We also prove that if validation succeeds, then the destination buffers contain
valid representations of their specified types. For instance, in the example
above, we prove that <code class="docutils literal notranslate"><span class="pre">destS</span></code> contains a valid representation of an <code class="docutils literal notranslate"><span class="pre">S64(r1,</span>
<span class="pre">destT)</span></code> and that <code class="docutils literal notranslate"><span class="pre">destT</span></code> contains a valid representation of <code class="docutils literal notranslate"><span class="pre">T(s1)</span></code>.</p>
<p><strong>Completeness</strong></p>
<p>For non-specialized specifications, we usually prove a completeness property,
namely that if the input contains a well-formatted representation of a type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, then the generated validator is guaranteed to accept that input.</p>
<p>Our proof for specialization does not cover this property: in particular,
formally, we have not yet proven that a well-formatted 32-bit input will always
be correctly coerced to a 64-bit layout and then accepted by the validator.</p>
<p>More concretely, an ideal result would be that an input correctly formatted
according to <code class="docutils literal notranslate"><span class="pre">R32Attempt</span></code> will always be accepted by the type <code class="docutils literal notranslate"><span class="pre">R32</span></code> computed
as a specialization of <code class="docutils literal notranslate"><span class="pre">R64</span></code>. However, this equivalence is not yet covered by
our proofs.</p>
<p>We are working to enrich our proofs to cover this property.</p>
<p><strong>Static assertions</strong></p>
<p>Computing coercions between different layouts of types based on
architecture-specific details of compilers is delicate. Rather than trusting
outright 3d’s implementation of the layout of structures including alignment
padding for 32- and 64-bit layouts, 3d emits static assertions to check that the
layout it computes corresponds to the layout for the corresponding structures
computed by whatever C compiler one uses to compile the code.</p>
<p>For our example above, 3d automatically generates a <code class="docutils literal notranslate"><span class="pre">refining</span></code> block and emits
the following C code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>


<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">UINT8</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UINT16</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UINT32</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">UINT64</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_T</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">___specialized32__T</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">___specialized32_T</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_S64</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT64</span><span class="w"> </span><span class="n">ptrT</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">S64</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">___specialized32__S64</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">ptrT</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">___specialized32_S64</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_R64</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT64</span><span class="w"> </span><span class="n">ptrS</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">R64</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">___specialized_R32</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>
<span class="w">  </span><span class="n">UINT32</span><span class="w"> </span><span class="n">ptrS</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">R32</span><span class="p">;</span>
<span class="cp">#define EVERPARSE_STATIC_ASSERT(e) typedef char __EVERPARSE_STATIC_ASSERT__[(e)?1:-1];</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">___specialized32_T</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">___specialized32_T</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">___specialized32_T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">S64</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">S64</span><span class="p">,</span><span class="w"> </span><span class="n">ptrT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">S64</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">___specialized32_S64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">___specialized32_S64</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">___specialized32_S64</span><span class="p">,</span><span class="w"> </span><span class="n">ptrT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">___specialized32_S64</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">R64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">R64</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">R64</span><span class="p">,</span><span class="w"> </span><span class="n">ptrS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">R32</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">R32</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">EVERPARSE_STATIC_ASSERT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">R32</span><span class="p">,</span><span class="w"> </span><span class="n">ptrS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="an-end-to-end-executable-example-1">
<h2>An End-to-end Executable Example<a class="headerlink" href="#an-end-to-end-executable-example-1" title="Permalink to this headline">¶</a></h2>
<p>A small but fully worked out example <a class="reference external" href="https://github.com/project-everest/everparse/tree/master/src/3d/tests/specialize_test">of specialization is available in the
EverParse repository</a>.</p>
<p>It shows an example similar to the one developed above, but linked with a main C
program and test driver. It also illustrates the use of nullable pointers in
conjunct with probing and specialization.</p>
</div>
<div class="section" id="limitations-on-variable-length-structures">
<h2>Limitations on Variable-length Structures<a class="headerlink" href="#limitations-on-variable-length-structures" title="Permalink to this headline">¶</a></h2>
<p>Automated specialization has only limited support for variable-length
structures. The main restriction is that a coercion between types cannot depend
on the data being coerced. We illustrate with a couple of examples:</p>
<p>Consider the following canonical tag-length-value encoding:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _UNION(UINT8 tag) {
    <span class="k">switch</span> (tag) {
        <span class="k">case</span> 0:
            UINT8 case0;
        <span class="k">case</span> 1:
            UINT16 case1;
        <span class="k">default</span>:
            UINT32 other;
    } field;
} UNION;

<span class="k">typedef</span> <span class="k">struct</span> _TLV
{
    UINT8 tag;
    UINT32 length;
    UNION(tag) payload[:byte-size length];
} TLV;
</pre></div>
</div>
<p>Now, let’s say one wanted to probe a pointer to a <code class="docutils literal notranslate"><span class="pre">TLV</span></code>, one could attempt
this:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _WRAPPER(EVERPARSE_COPY_BUFFER_T Output)
{
    TLV *tlv <span class="k">probe</span> ProbeAndCopy(length=???, destination=Output);
} WRAPPER;
</pre></div>
</div>
<p>But, this type is not expressible: when writing a probe, one needs to provide a
<code class="docutils literal notranslate"><span class="pre">length</span></code>, bounding the amount of data to be copied into the <code class="docutils literal notranslate"><span class="pre">Output</span></code> buffer.
But, in this case, there is no length to provide.</p>
<p>We could try another approach by expecting the context to bound the length in
advance:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _UNION(UINT8 tag) {
    <span class="k">switch</span> (tag) {
        <span class="k">case</span> 0:
            UINT8 case0;
        <span class="k">case</span> 1:
            UINT16 case1;
        <span class="k">default</span>:
            UINT32 other;
    } field;
} UNION;

<span class="k">typedef</span> <span class="k">struct</span> _TLV(UINT32 Len)
{
    UINT8 tag;
    UINT32 length { length == Len };
    UNION(tag) payload[:byte-size length];
} TLV;

<span class="k">typedef</span> <span class="k">struct</span> _WRAPPER(UINT32 Len, EVERPARSE_COPY_BUFFER_T Output)
<span class="k">where</span> (Len &gt; 5)
{
    TLV(Len - 5) *tlv <span class="k">probe</span> ProbeAndCopy(length=Len, destination=Output);
} WRAPPER;
</pre></div>
</div>
<p>This works: if the caller can bound the entire size of the pointed to data and
pass it to <code class="docutils literal notranslate"><span class="pre">WRAPPER</span></code> as a parameter <code class="docutils literal notranslate"><span class="pre">Len</span></code>, then we can use that as a bound.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">probe</span> ProbeAndCopy
<span class="k">extern</span> <span class="k">probe</span> (READ UINT8) ProbeAndReadU8
<span class="k">extern</span> <span class="k">probe</span> (WRITE UINT8) WriteU8
<span class="k">extern</span> <span class="k">probe</span> (READ UINT32) ProbeAndReadU32
<span class="k">extern</span> <span class="k">probe</span> (WRITE UINT32) WriteU32
<span class="k">extern</span> <span class="k">probe</span> (WRITE UINT64) WriteU64
<span class="k">extern</span> <span class="k">probe</span> (INIT) ProbeInit
<span class="k">extern</span> <span class="k">PURE</span> UINT64 UlongToPtr(UINT32 ptr)

<span class="k">typedef</span> <span class="k">struct</span> _UNION(UINT8 tag) {
    <span class="k">switch</span> (tag) {
        <span class="k">case</span> 0:
            UINT8 case0;
        <span class="k">case</span> 1:
            UINT16 case1;
        <span class="k">default</span>: 
            UINT32 other;
    } field;
} UNION;

<span class="k">typedef</span> <span class="k">struct</span> _TLV(UINT16 Len)
{
    UINT8 tag;
    UINT32 length { length == Len };
    UNION(tag) payload[:byte-size Len];
} TLV;

<span class="k">typedef</span> <span class="k">struct</span> _WRAPPER(UINT16 Len, EVERPARSE_COPY_BUFFER_T Output)
<span class="k">where</span> (Len &gt; 5)
{
    TLV(Len - 5) *tlv
        <span class="k">probe</span> ProbeAndCopy(length=Len, destination=Output);
} WRAPPER;

<span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) WRAPPER WRAPPER_32;

<span class="k">entrypoint</span>
<span class="k">casetype</span> _ENTRY(
    Bool Requestor32,
    UINT16 Len,
    EVERPARSE_COPY_BUFFER_T Output)
{
    <span class="k">switch</span> (Requestor32)
    {
        <span class="k">case</span> true:
            WRAPPER_32(Len, Output) w32;

        <span class="k">case</span> false:
            WRAPPER(Len, Output) w64;
    }
} ENTRY;
</pre></div>
</div>
<p>However, we remark on a few limitations:</p>
<p>First, 3d does not support arbitrary data dependences in coercions. One can only
depend on fields with simple, unconstrained types. For example, replacing the
TLV type in the listing above with the following specification is rejected:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _TLV(UINT16 Len)
{
    UINT8 tag { tag == 0 || tag == 1 || tag == 2 };
    UINT32 length { length == Len };
    UNION(tag) payload[:byte-size Len];
} TLV;
</pre></div>
</div>
<p>The error message reported by 3d is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>./SpecializeDep1.3d:(24,11):
(Error) Coercive probes cannot read integer or pointer types with constraints or enum types;
field tag has type UINT8 with constraint (((tag = 0uy) || (tag = 1uy)) || (tag = 2uy))
</pre></div>
</div>
<p>3d’s determination of data dependence is a syntactic criterion, e.g., if one
were to use <code class="docutils literal notranslate"><span class="pre">length</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Len</span></code> in the specification, as shown below,
then once again 3d’s reports an error:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _TLV(UINT16 Len)
{
    UINT8 tag;
    UINT32 length { length == Len };
    UNION(tag) payload[:byte-size length];
} TLV;
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>./SpecializeDep1.3d:(25,12): (Error) Coercive probes cannot read integer or pointer types with constraints or enum types;
field length has type UINT32 with constraint (length = (UINT32) Len)
</pre></div>
</div>
<p>Note, one does not always need the calling context to pass in arguments like
<code class="docutils literal notranslate"><span class="pre">Len</span></code>: these just need to be values in scope at the point at which the probe
is used. For instance, the following would work too, for a pointer to a variable
length array, each of whose elements is a <code class="docutils literal notranslate"><span class="pre">UNION(tag)</span></code>:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _UNION_ARRAY(UINT8 tag, UINT32 len)
{
    UNION(tag) payload[:byte-size len];
} UNION_ARRAY;

<span class="k">typedef</span> <span class="k">struct</span> _TLV_ALT(EVERPARSE_COPY_BUFFER_T Output)
{
    UINT8 tag;
    UINT32 length;
    UNION_ARRAY(tag, length) *ptr 
        <span class="k">probe</span> ProbeAndCopy(length=length, destination=Output);
} TLV_ALT;

<span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) TLV_ALT TLV_ALT_32;
</pre></div>
</div>
<div class="section" id="data-dependency-for-well-formedness">
<h3>Data Dependency for Well-formedness<a class="headerlink" href="#data-dependency-for-well-formedness" title="Permalink to this headline">¶</a></h3>
<p>There is another form of data dependency that is also not supported: dependence
on data constraints that ensure well-formedness of specifications. The following
variant of our previous example illustrates.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _TLV(UINT8 Expected, UINT16 Len)
{
    UINT8 tag { tag == Expected };
    UINT32 length { Len &gt; 5 &amp;&amp; length == Len - 5 };
    UNION(Expected) payload[:byte-size (Len - 5)];
} TLV;

<span class="k">typedef</span> <span class="k">struct</span> _WRAPPER(UINT8 Expected, UINT16 Len, EVERPARSE_COPY_BUFFER_T Output)
{
    TLV(Expected, Len) *tlv
        <span class="k">probe</span> ProbeAndCopy(length=Len, destination=Output);
} WRAPPER;
</pre></div>
</div>
<p>In this variant, rather than constrain <code class="docutils literal notranslate"><span class="pre">Len</span> <span class="pre">&gt;</span> <span class="pre">5</span></code> in the <code class="docutils literal notranslate"><span class="pre">Wrapper</span></code>, we add a
constraint on the <code class="docutils literal notranslate"><span class="pre">length</span></code> field enforcing <code class="docutils literal notranslate"><span class="pre">Len</span> <span class="pre">&gt;</span> <span class="pre">5</span></code>, and then using <code class="docutils literal notranslate"><span class="pre">Len</span> <span class="pre">-</span>
<span class="pre">5</span></code> for the length of <code class="docutils literal notranslate"><span class="pre">payload</span></code>—the constraint ensures that the subtraction
<code class="docutils literal notranslate"><span class="pre">Len</span> <span class="pre">-</span> <span class="pre">5</span></code> does not underflow.</p>
<p>However, if we try to specialize <code class="docutils literal notranslate"><span class="pre">WRAPPER</span></code> to 32 bits:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">specialize</span> (<span class="k">pointer</span>(*), <span class="k">pointer</span>(UINT32)) WRAPPER WRAPPER_32;
</pre></div>
</div>
<p>We get the following <em>verification</em> error:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>* Error 19 at out/SpecializeDep1Fail.fst(195,2-205,63):
- Cannot verify u16 subtraction
- The SMT solver could not prove the query. Use --query_stats for more
  details.
- Also see: SpecializeDep1Fail.3d(22,40-22,40)
</pre></div>
</div>
<p>3d accepts the specification and then translates it to F* for well-formedness
checking: but F* rejects the specification saying it cannot prove that the
subtraction <code class="docutils literal notranslate"><span class="pre">Len</span> <span class="pre">-</span> <span class="pre">5</span></code> does not underflow. This is because, again, the coercion
of <code class="docutils literal notranslate"><span class="pre">TLV</span></code> from 32- to 64-bits is not data dependent, and as such, the
constraint on the <code class="docutils literal notranslate"><span class="pre">length</span></code> field is not enforced by the coercion, and F*
rightfully rejects the subtraction as unsafe.</p>
</div>
</div>
<div class="section" id="and-end-to-end-example-with-variable-length-structures">
<h2>And End-to-end Example with Variable-length Structures<a class="headerlink" href="#and-end-to-end-example-with-variable-length-structures" title="Permalink to this headline">¶</a></h2>
<p>Although data dependency is forbidden in coercions, there are many cases where
variable-length structures fit well with 3d’s support for auto-specialization.</p>
<p>A small but fully worked out example <a class="reference external" href="https://github.com/project-everest/everparse/tree/master/src/3d/tests/specialize_test2">of specialization with variable-length
structures is available in the EverParse repository</a>,
including a main file driving the generated code with test input.</p>
<p>Another example, <a class="reference external" href="https://github.com/project-everest/everparse/tree/master/src/3d/tests/specialize_tagged_union_array">with data dependent tagged unions</a>,
is also available.</p>
</div>
<div class="section" id="other-forms-of-specialization">
<h2>Other forms of Specialization<a class="headerlink" href="#other-forms-of-specialization" title="Permalink to this headline">¶</a></h2>
<p>Today, 3d only supports specialized 64-bit pointer types to 32-bit pointers. In
the future, we envision adding support for other forms of specialization, e.g.,
automatically specializing little-endian to big-endian types.</p>
</div>
</div>
<div class="section" id="comments">
<h1>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h1>
<p>The user can insert comments in their <code class="docutils literal notranslate"><span class="pre">.3d</span></code> file, some of which will
be inserted into the <code class="docutils literal notranslate"><span class="pre">.c</span></code> file:</p>
<p>There are three kinds of comments:</p>
<ul class="simple">
<li>Block comments are delimited by <code class="docutils literal notranslate"><span class="pre">/*</span></code> and <code class="docutils literal notranslate"><span class="pre">*/</span></code> and do not
nest. These are never propagated to the C code.</li>
<li>Line comments begin with <code class="docutils literal notranslate"><span class="pre">//</span></code> and are propagated to C
heuristically close to the translated source construct.</li>
<li>Each top-level declaration can be preceded by a type declaration
comment delimited by <code class="docutils literal notranslate"><span class="pre">/*++</span></code> and <code class="docutils literal notranslate"><span class="pre">--*/</span></code>: These are propagated to
the C code preceding the C procedure corresponding to the validator
of the source type.</li>
</ul>
</div>
<div class="section" id="adding-copyright-notices-to-produced-c-h-files">
<h1>Adding copyright notices to produced .c/.h files<a class="headerlink" href="#adding-copyright-notices-to-produced-c-h-files" title="Permalink to this headline">¶</a></h1>
<p>If, along with some <code class="docutils literal notranslate"><span class="pre">MyFile.3d</span></code>, in the same directory, you provide
a file <code class="docutils literal notranslate"><span class="pre">MyFile.3d.copyright.txt</span></code> that contains syntactically correct
C comments (with <code class="docutils literal notranslate"><span class="pre">//</span></code> or <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></code>), then EverParse will prepend
<code class="docutils literal notranslate"><span class="pre">MyFile.c</span></code>, <code class="docutils literal notranslate"><span class="pre">MyFileWrapper.c</span></code> and their corresponding <code class="docutils literal notranslate"><span class="pre">.h</span></code> with
these comments. You do not need to mention this file on the command
line.</p>
<p>These comments can contain the following special symbols:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">EVERPARSEVERSION</span></code>, which EverParse will automatically replace
with its version number;</li>
<li><code class="docutils literal notranslate"><span class="pre">FILENAME</span></code>, which EverParse will automatically replace with the
name of the <code class="docutils literal notranslate"><span class="pre">.c</span></code> / <code class="docutils literal notranslate"><span class="pre">.h</span></code> file being generated.</li>
<li><code class="docutils literal notranslate"><span class="pre">EVERPARSEHASHES</span></code>, which EverParse will automatically replace with
a hash of the contents of the corresponding .3d file for the purpose
of <code class="docutils literal notranslate"><span class="pre">--check_hashes</span> <span class="pre">inplace</span></code> or <code class="docutils literal notranslate"><span class="pre">--check_inplace_hash</span></code> (see <a class="reference external" href="3d.html#alternate-mode-hash-checking">Hash
checking</a>).</li>
</ul>
</div>
<div class="section" id="modular-structure-and-files">
<h1>Modular structure and files<a class="headerlink" href="#modular-structure-and-files" title="Permalink to this headline">¶</a></h1>
<p>A 3d specification is described in a collection of modules, each
stored in a file with a <code class="docutils literal notranslate"><span class="pre">.3d</span></code> extension. The name of a module is
derived from its filename, i.e., the file <code class="docutils literal notranslate"><span class="pre">A.3d</span></code> defines a module
named <code class="docutils literal notranslate"><span class="pre">A</span></code>. A module can <code class="docutils literal notranslate"><span class="pre">Derived</span></code> (in Derived.3d) can refer to
another module <code class="docutils literal notranslate"><span class="pre">Base</span></code> (in Base.3d) by its name, allowing definitions
in <code class="docutils literal notranslate"><span class="pre">Derived</span></code> to reuse the definitions that are exported in <code class="docutils literal notranslate"><span class="pre">Base</span></code>.</p>
<p>For example, in module <code class="docutils literal notranslate"><span class="pre">Base</span></code> we could define the following types:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">export</span>
<span class="k">typedef</span> UINT32 ULONG;

<span class="k">export</span>
<span class="k">typedef</span> <span class="k">struct</span> _Pair {
   ULONG first;
   ULONG second;
} Pair;

<span class="k">typedef</span> <span class="k">struct</span> _Mine {
   UINT8 f;
   UINT8 g;
} Mine;
</pre></div>
</div>
<p>Note, the <code class="docutils literal notranslate"><span class="pre">export</span></code> qualifier indicate that these definitions may be
referenced from another module. Types that are not exproted (like
<code class="docutils literal notranslate"><span class="pre">Mine</span></code>) are not visible from another module.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Derived</span></code> we can use the type from <code class="docutils literal notranslate"><span class="pre">Base</span></code> by referring to it
using a fully qualified name of the form <code class="docutils literal notranslate"><span class="pre">&lt;MODULE</span> <span class="pre">NAME&gt;.&lt;IDENTIFIER&gt;</span></code>.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _Triple {
  Base::Pair pair;
  Base::ULONG third;
} Triple;
</pre></div>
</div>
<p>3d also allows defining module abbreviations. For example, using
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">Base</span></code> we introduce a shorter name for the module
<code class="docutils literal notranslate"><span class="pre">Base</span></code> for use within the current module.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> B = Base
<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _Quad {
  B::Pair _12;
  B::Pair _34;
} Quad;
</pre></div>
</div>
<p>A commented example is available <a class="reference external" href="https://github.com/project-everest/everparse/blob/master/src/3d/tests/modules/">in the EverParse repository</a>.</p>
</div>
<div class="section" id="error-handling">
<h1>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h1>
<p>When a validator fails, EverParse supports invoking a user-provided
callback with contextual information about the failure.</p>
<p>An error handling callback is a C procedure with the following signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ErrorHandler</span><span class="p">)(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">TypeName</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">FieldName</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ErrorReason</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">ErrorCode</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">Context</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">Base</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">StartPosition</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">EndPosition</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Every EverParse validator is parameterized by:</p>
<ul class="simple">
<li>A function pointer, of type <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code></li>
<li>A context parameter, <code class="docutils literal notranslate"><span class="pre">uint8_t*</span> <span class="pre">Context</span></code></li>
</ul>
<p>At the top-level, when calling into EverParse from an application, one
can instantiate both the <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code> with a function of one’s
choosing and the <code class="docutils literal notranslate"><span class="pre">Context</span></code> argument with a pointer to some
application-specific context.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code> expects</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">Base</span></code> and <code class="docutils literal notranslate"><span class="pre">Context</span></code> pointers to refer to live and
disjoint pieces of memory.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">Length</span></code> to be the length in bytes of valid memory pointed
to by <code class="docutils literal notranslate"><span class="pre">Base</span></code> and for <code class="docutils literal notranslate"><span class="pre">StartPosition</span> <span class="pre">&lt;=</span> <span class="pre">EndPosition</span> <span class="pre">&lt;=</span> <span class="pre">Length</span></code>.</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code> can</p>
<blockquote>
<div><ul class="simple">
<li>Read from all the pointers</li>
<li>May only modify the memory reference by <code class="docutils literal notranslate"><span class="pre">Context</span></code>.</li>
</ul>
</div></blockquote>
<p>When validating a field <code class="docutils literal notranslate"><span class="pre">f</span></code> in a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, in case the validator
fails, EverParse calls the user-provided <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code>, passing in
the following arguments:</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">TypeName</span></code> argument is the name of the type <code class="docutils literal notranslate"><span class="pre">T</span></code></li>
<li>The <code class="docutils literal notranslate"><span class="pre">FieldName</span></code> argument is name of the field <code class="docutils literal notranslate"><span class="pre">f</span></code></li>
<li>The <code class="docutils literal notranslate"><span class="pre">ErrorReason</span></code> and <code class="docutils literal notranslate"><span class="pre">ErrorCode</span></code> arguments are related and can be one of the following pairs:<ul>
<li>“generic error”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_GENERIC</span></code> (1uL)</li>
<li>“not enough data”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_NOT_ENOUGH_DATA</span></code> (2uL)</li>
<li>“impossible”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_IMPOSSIBLE</span></code> (3uL)</li>
<li>“list size not multiple of element size”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_LIST_SIZE_NOT_MULTIPLE</span></code> (4uL)</li>
<li>“action failed”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_ACTION_FAILED</span></code> (5uL)</li>
<li>“constraint failed”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_CONSTRAINT_FAILED</span></code> (6uL)</li>
<li>“unexpected padding”, <code class="docutils literal notranslate"><span class="pre">EVERPARSE_ERROR_UNEXPECTED_PADDING</span></code> (7uL)</li>
<li>“unspecified”, with the <code class="docutils literal notranslate"><span class="pre">ErrorCode</span> <span class="pre">&gt;</span> <span class="pre">7uL</span></code></li>
</ul>
</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Context</span></code> argument is the user-provided <code class="docutils literal notranslate"><span class="pre">Context</span></code> pointer</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Length</span></code> argument is the length in bytes of the input buffer</li>
<li>The <code class="docutils literal notranslate"><span class="pre">Base</span></code> argument is a pointer to the base of the input buffer</li>
<li>The <code class="docutils literal notranslate"><span class="pre">StartPosition</span></code> argument is the offset from <code class="docutils literal notranslate"><span class="pre">Base</span></code> of the
start of the field <code class="docutils literal notranslate"><span class="pre">f</span></code></li>
<li>The <code class="docutils literal notranslate"><span class="pre">EndPosition</span></code> argument is the offset from <code class="docutils literal notranslate"><span class="pre">Base</span></code> of the
end of the field <code class="docutils literal notranslate"><span class="pre">f</span></code> at which the validation failure occurred.</li>
</ul>
</div></blockquote>
<p>Following a validation failure at a given field, EverParse will invoke
the <code class="docutils literal notranslate"><span class="pre">ErrorHandler</span></code> at each enclosing type as well. This allows a
caller to reconstruct a stack trace of a failing validation.</p>
<p>EverParse generates a default error handler that records just the
deepest validation failure that occurred.</p>
</div>
<div class="section" id="fully-worked-examples-tcp-segment-headers">
<h1>Fully worked examples: TCP Segment Headers<a class="headerlink" href="#fully-worked-examples-tcp-segment-headers" title="Permalink to this headline">¶</a></h1>
<p>The classic <a class="reference external" href="https://tools.ietf.org/html/rfc793">IETF RFC 793</a> from
1981 introduces the TCP protocol, including the format of the header
of TCP segments. The format has been extended slightly since then, to
accommodate new options and flags—this <a class="reference external" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">Wikipedia page</a>
provides a good summary.</p>
<p>Reproduced below is an ASCII depiction of the format of TCP
headers. In this section, we show how to specify this format in
3d. The full specification can be found <a class="reference external" href="https://github.com/project-everest/everparse/tree/master/src/3d/tests/tcpip/TCP.3d">here</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |     |N|C|E|U|A|P|R|S|F|                               |
| Offset| Rese|S|W|C|R|C|S|S|Y|I|            Window             |
|       | rved| |R|E|G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">-</span></code> in the diagram represents a single bit, with fioelds
separated by vertical bars <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<p>The main subtle element of the specification is the handling of the
<code class="docutils literal notranslate"><span class="pre">DataOffset</span></code> field. It is a 4-bit value representing an offset from
the beginning of the segment, in 32-bit increments, of the start of
the <code class="docutils literal notranslate"><span class="pre">data</span></code> field. The <code class="docutils literal notranslate"><span class="pre">Options</span></code> and <code class="docutils literal notranslate"><span class="pre">Padding</span></code> fields are
optional, so the <code class="docutils literal notranslate"><span class="pre">DataOffset</span></code> field is used to encode the size of
the <code class="docutils literal notranslate"><span class="pre">Options</span></code> field. As such, <code class="docutils literal notranslate"><span class="pre">DataOffset</span></code> is always at least
<code class="docutils literal notranslate"><span class="pre">5</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Options</span></code> field itself is an array of tagged unions,
representing various kinds of options. Padding and the end of the
options array ensures that the <code class="docutils literal notranslate"><span class="pre">data</span></code> fields is always begins at a
multiple of 32-bits from the start of the segment.</p>
<p>Additionally, semantic constraints restrict the values of the fields
depending on the values of some other fields. For example, the
Acknowledgement number can only be non-zero when the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> bit is
set.</p>
<p>To specify the type of a TCP header, we begin by defining some basic
types.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> UINT16 PORT;
<span class="k">typedef</span> UINT32 SEQ_NUMBER;
<span class="k">typedef</span> UINT32 ACK_NUMBER;
<span class="k">typedef</span> UINT16 WINDOW;
<span class="k">typedef</span> UINT16 CHECK_SUM;
<span class="k">typedef</span> UINT16 URGENT_PTR;
</pre></div>
</div>
<p>The source and destination port each occupy 16 bits and are
represented by a <code class="docutils literal notranslate"><span class="pre">UINT16</span></code>; the sequence and acknowledgment number
fields are <code class="docutils literal notranslate"><span class="pre">UINT32</span></code> etc.</p>
<p>Next, we define the various kind of options that are allowed. Every
option begins with an option kind tag, an 8-bit value. Depending on
the option kind, a variable number of bits of an option value can
follow. The permitted option kinds are:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span>#define OPTION_KIND_END_OF_OPTION_LIST 0x00
#define OPTION_KIND_NO_OPERATION 0x01
#define OPTION_KIND_MAX_SEG_SIZE 0x02
#define OPTION_KIND_WINDOW_SCALE 0x03
#define OPTION_KIND_SACK_PERMITTED 0x04
#define OPTION_KIND_SACK 0x05
#define OPTION_KIND_TIMESTAMP 0x08
</pre></div>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">OPTION</span></code> is parameterized by a boolean, <code class="docutils literal notranslate"><span class="pre">MaxSegSizeAllowed</span></code>,
which constraints when the <code class="docutils literal notranslate"><span class="pre">OPTION_KIND_MAX_SEG_SIZE</span></code> is allowed to
be present—it turns out, the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> bit in the header must be set
for this option to be allowed. The general shape of an <code class="docutils literal notranslate"><span class="pre">OPTION</span></code> is
as below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _OPTION(Bool MaxSegSizeAllowed)
{
    UINT8 OptionKind;
    OPTION_PAYLOAD(OptionKind, MaxSegSizeAllowed) OptionPayload;
} OPTION;
</pre></div>
</div>
<p>We have an <code class="docutils literal notranslate"><span class="pre">OptionKind</span></code> field followed by an <code class="docutils literal notranslate"><span class="pre">OptionPayload</span></code> that
depends on the <code class="docutils literal notranslate"><span class="pre">OptionKind</span></code> and the <code class="docutils literal notranslate"><span class="pre">MaxSegSizeAllowed</span></code> flag.</p>
<p>Next, to define the <code class="docutils literal notranslate"><span class="pre">OPTION_PAYLOAD</span></code> type, we use a <code class="docutils literal notranslate"><span class="pre">casetype</span></code>, as
shown below.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">casetype</span> _OPTION_PAYLOAD(UINT8 OptionKind, Bool MaxSegSizeAllowed)
{
  <span class="k">switch</span>(OptionKind)
  {
   <span class="k">case</span> OPTION_KIND_END_OF_OPTION_LIST:
     unit EndOfList;

   <span class="k">case</span> OPTION_KIND_NO_OPERATION:
     unit Noop;

   <span class="k">case</span> OPTION_KIND_MAX_SEG_SIZE:
     MAX_SEG_SIZE_PAYLOAD(MaxSegSizeAllowed) MaxSegSizePayload;

   <span class="k">case</span> OPTION_KIND_WINDOW_SCALE:
     WINDOW_SCALE_PAYLOAD WindowScalePayload;

   <span class="k">case</span> OPTION_KIND_SACK_PERMITTED:
     UINT8 SackPermittedPayload;

   <span class="k">case</span> OPTION_KIND_SACK:
     SELECTIVE_ACK_PAYLOAD SelectiveAckPayload;

   <span class="k">case</span> OPTION_KIND_TIMESTAMP:
     TIMESTAMP_PAYLOAD TimestampPayload;
  }
} OPTION_PAYLOAD;
</pre></div>
</div>
<p>In the first two cases of <code class="docutils literal notranslate"><span class="pre">OptionKind</span></code>, no payload is expected. The
<code class="docutils literal notranslate"><span class="pre">unit</span></code> type in 3d is an empty type—it consumes no space in the
message format.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">OPTION_KIND_MAX_SEG_SIZE</span></code>, we have the following payload—the
use of the <code class="docutils literal notranslate"><span class="pre">where`</span> <span class="pre">constraint</span> <span class="pre">ensures</span> <span class="pre">that</span> <span class="pre">this</span> <span class="pre">case</span> <span class="pre">is</span> <span class="pre">present</span> <span class="pre">only</span>
<span class="pre">when</span> <span class="pre">`MaxSegSizeAllowed</span> <span class="pre">==</span> <span class="pre">true</span></code>. The payload is a length field (4
bytes) and a 2-byte <code class="docutils literal notranslate"><span class="pre">MaxSegSize</span></code> value.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _MAX_SEG_SIZE_PAYLOAD(Bool MaxSegSizeAllowed)
<span class="k">where</span> MaxSegSizeAllowed
{
  UINT8 Length
  {
    Length == 4
  };
  UINT16 MaxSegSize;
} MAX_SEG_SIZE_PAYLOAD;
</pre></div>
</div>
<p>The other cases are relatively straightforward, where
<code class="docutils literal notranslate"><span class="pre">SELECTIVE_ACK_PAYLOAD</span></code> and <code class="docutils literal notranslate"><span class="pre">TIMESTAMP_PAYLOAD</span></code> illustrate the use
of variable length arrays.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _WINDOW_SCALE_PAYLOAD
{
  UINT8 Length
  {
    Length == 3
  };
  UINT8 WindowScale;
} WINDOW_SCALE_PAYLOAD;


<span class="k">typedef</span> <span class="k">struct</span> _SELECTIVE_ACK_PAYLOAD
{
  UINT8 Length
  {
    Length == 10 ||
    Length == 18 ||
    Length == 26 ||
    Length == 34
  };
  UINT8 SelectiveAck[:byte-size (Length - 2)];
} SELECTIVE_ACK_PAYLOAD;


<span class="k">typedef</span> <span class="k">struct</span> _TIMESTAMP_PAYLOAD
{
  UINT8 Length
  {
    Length == 10
  };
  UINT8 TimeStamp[:byte-size (Length - 2)];
} TIMESTAMP_PAYLOAD;
</pre></div>
</div>
<p>Finally, we can assemble our top-level TCP header type, as shown
below. The specification of the options array is weaker than it could
be. It currently permits an end-of-options-list option to appear
anywhere in the Options list, rather than as just the last
element. This can be improved by using a more advanced combinator from
EverParse, however we leave it as is for simplicity of this example.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="c">/*++</span>
<span class="c">  The top-level type of a TCP Header</span>

<span class="c">  Arguments:</span>

<span class="c">  * UINT32 SegmentLength, the size of the segment,</span>
<span class="c">    including both header and data, passed in by the caller</span>

<span class="c">  --*/</span>
<span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _TCP_HEADER(UINT32 SegmentLength)
{
  PORT            SourcePort;
  PORT            DestinationPort;
  SEQ_NUMBER      SeqNumber;
  ACK_NUMBER      AckNumber;
  UINT16          DataOffset:4
  { <span class="c">//DataOffset is in units of 32 bit words</span>
    <span class="k">sizeof</span>(<span class="k">this</span>) &lt;= DataOffset * 4 &amp;&amp; <span class="c">//DataOffset points after the static fields</span>
    DataOffset * 4 &lt;= SegmentLength <span class="c">//and within the current segment</span>
  };
  UINT16          Reserved:3
  {
    Reserved == 0 <span class="c">//Reserved bytes are unused</span>
  };
  UINT16          NS:1;
  UINT16          CWR:1;
  UINT16          ECE:1;
  UINT16          URG:1;
  UINT16          ACK:1
  {
    AckNumber == 0 ||
    ACK == 1 <span class="c">//AckNumber can only be set if the ACK flag is set</span>
  } ;
  UINT16          PSH:1;
  UINT16          RST:1;
  UINT16          SYN:1;
  UINT16          FIN:1;
  WINDOW          Window;
  CHECK_SUM       CheckSum;
  URGENT_PTR      UrgentPointer
  {
    UrgentPointer == 0 ||
    URG == 1 <span class="c">//UrgentPointer can only be set if the URG flag is set</span>
  };
  <span class="c">//The SYN=1 condition indicates when MAX_SEG_SIZE option can be received</span>
  <span class="c">//This is an array of options consuming</span>
  OPTION(SYN==1)  Options[:byte-size (DataOffset * 4) - <span class="k">sizeof</span>(<span class="k">this</span>)];
  UINT8           Data[SegmentLength - (DataOffset * 4)];
} TCP_HEADER;
</pre></div>
</div>
<p>The type is parameterized by <code class="docutils literal notranslate"><span class="pre">SegmentLength</span></code>, the size in bytes
determined by the caller of the entire segment, including the header
and the data.</p>
<p>The first four fields, <code class="docutils literal notranslate"><span class="pre">SourcePort</span></code>, <code class="docutils literal notranslate"><span class="pre">DestinationPort</span></code>,
<code class="docutils literal notranslate"><span class="pre">SeqNumber</span></code> and <code class="docutils literal notranslate"><span class="pre">AckNumber</span></code> are straightforward.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DataOffset</span></code> field is 4-bit value constrained to point beyond
the static fields of the header. Here <code class="docutils literal notranslate"><span class="pre">sizeof(this)</span></code> is a 3d
compile-time constant referring to the size of the non-variable length
prefix of the current type, i.e., the sum of the length in bytes of
all the fields up to the <code class="docutils literal notranslate"><span class="pre">Options</span></code> field. In this case, that number
is <code class="docutils literal notranslate"><span class="pre">20</span></code>. <code class="docutils literal notranslate"><span class="pre">DataOffset</span></code> is also constrained to reference an offset
within the curent segment.</p>
<p>Next, we have 3 reserved bits, following by 1 bit each for the 9
flags. The <code class="docutils literal notranslate"><span class="pre">Ack</span></code> flag is interesting, since its constraints states
that the <code class="docutils literal notranslate"><span class="pre">AckNumber</span></code> can be non-zero only if the <code class="docutils literal notranslate"><span class="pre">Ack</span></code> bit is set.</p>
<p>Then, we have a <code class="docutils literal notranslate"><span class="pre">Window</span></code> and <code class="docutils literal notranslate"><span class="pre">CheckSum</span></code>, both of which are
straightforward. Note, we do not specify the <code class="docutils literal notranslate"><span class="pre">CheckSum</span></code> as part of
the format—that’s up to an application-specific check to
confirm. Alternatively, one could check this using a user-provided
action callback, though this is not yet supported.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">UrgentPointer</span></code> field is similar to <code class="docutils literal notranslate"><span class="pre">AckNumber</span></code> in that it can
only be non-zero when the <code class="docutils literal notranslate"><span class="pre">URG</span></code> flag is set.</p>
<p>Then, we have an <code class="docutils literal notranslate"><span class="pre">Options</span></code> array, using the condition <code class="docutils literal notranslate"><span class="pre">SYN==1</span></code> to
determine the <code class="docutils literal notranslate"><span class="pre">MaxSegSizeAllowed</span></code> condition. The size in bytes of
the options array is variable and includes also the padding field, to
ensure 32-bit alignment. Note, this type is little too permissive, as
it will permit options arrays where the end-of-list option kind is not
necessarily only the last element.</p>
<p>Finally, we have the data field itself, whose byte size is bytes is
the computed expression.</p>
<div class="section" id="generated-code">
<h2>Generated code<a class="headerlink" href="#generated-code" title="Permalink to this headline">¶</a></h2>
<p>Running the EverParse toolchain on the TCP segment header
specification produces a C procedure with the following signature, in <code class="docutils literal notranslate"><span class="pre">TCPWrapper.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">TcpCheckTcpHeader</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">___SegmentLength</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>This procedure is a validator for the <code class="docutils literal notranslate"><span class="pre">TCP_HEADER</span></code> type. The caller
passes in three parameters:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">__SegmentLength</span></code>, representing the <code class="docutils literal notranslate"><span class="pre">SegmentLength</span></code> argument of
the <code class="docutils literal notranslate"><span class="pre">TCPHeader</span></code> type in the 3d specification.</li>
<li><code class="docutils literal notranslate"><span class="pre">base</span></code>: a pointer to an array of bytes</li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: a lower bound on the length of that array that <code class="docutils literal notranslate"><span class="pre">base</span></code>
points to.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">TcpCheckTcpHeader</span></code> returns <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if, and only if, the contents
of <code class="docutils literal notranslate"><span class="pre">base</span></code> represent a valid <code class="docutils literal notranslate"><span class="pre">TCPHeader</span></code>, while enjoying all the
guarantees of memory safety, arithmetic safety, double-fetch freedom,
not modifying any of the caller’s memory, not allocating any heap
data, and being provably functional correct.</p>
</div>
<div class="section" id="error-handling-1">
<h2>Error handling<a class="headerlink" href="#error-handling-1" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">TCPWrapper.h</span></code> includes a default error handler to report the leaf
validation failure. It also expects a client module to supply an
implementation of</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">TcpEverParseError</span><span class="p">(</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">TypeName</span><span class="p">,</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">FieldName</span><span class="p">,</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">Reason</span><span class="p">,</span>
<span class="w">     </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">ErrorCode</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be instantiated with a procedure to, say, log an error.</p>
<p>Alternatively, the default error handler in <code class="docutils literal notranslate"><span class="pre">TCPWrapper.h</span></code> can be
replaced by a custom error handler of your choosing.</p>
</div>
</div>
<div class="section" id="fully-worked-examples-elf-files">
<h1>Fully worked examples: ELF files<a class="headerlink" href="#fully-worked-examples-elf-files" title="Permalink to this headline">¶</a></h1>
<p>ELF (Executable and Linkable Format) is a common, standard file format
for various kinds of binary files (object files, executables, shared
libraries, and core dumps). The file format is described as
C-structures in the <a class="reference external" href="https://man7.org/linux/man-pages/man5/elf.5.html">elf.h</a> file.</p>
<p>In this section we develop (parts of) a 3d specification for 64-bits
ELF files and describe how it can be integrated in existing projects
for validating potentially untrusted ELF files. A complete ELF
specification can be found in the <a class="reference external" href="https://github.com/project-everest/everparse/blob/master/src/3d/tests/ELF.3d">3d test suite</a>.</p>
<p>An ELF file consists of an ELF header, followed by a program header
table and a section header table. Both the tables are optional and
describe the rest of the ELF file. The ELF header specifies the
offsets and the number of entries in each of the tables. One
interesting aspect of validating ELF files is then to check that both
the tables contain the specified number of entries and point to the
valid parts of the rest of the ELF file.</p>
<p>The ELF header starts with a 16 byte array. The first four bytes of
the array are fixed: 0x7f, followed by ‘E’, ‘L’, and ‘F’. Other bytes
of the array specify the binary architecture (32-bits or 64-bits),
endianness, ELF specification version, target OS, and ABI version of
the file. The last 7 bytes of the array are padding bytes set to 0. To
be able to constrain the individual bytes of this array, we specify in
3d as a struct.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _E_IDENT
{
  UCHAR    ZERO    { ZERO == 0x7f };
  UCHAR    ONE     { ONE == 0x45 };
  UCHAR    TWO     { TWO == 0x4c };
  UCHAR    THREE   { THREE == 0x46 };

  <span class="c">//This 3d spec applies to 64-bit only currently</span>
  ELFCLASS FOUR    { FOUR == ELFCLASS64 };

  ELFDATA  FIVE;

  <span class="c">//ELF specification version is always set to 1</span>
  UCHAR    SIX     { SIX == 1 };

  ELFOSABI SEVEN;

  <span class="c">//ABI version, always set to 0</span>
  ZeroByte EIGHT;

  <span class="c">//padding, remaining 7 bytes are 0</span>
  ZeroByte NINE_FIFTEEN[E_IDENT_PADDING_SIZE];
} E_IDENT;
</pre></div>
</div>
<p>(The omitted definitions can be found in the <a class="reference external" href="https://github.com/project-everest/everparse/blob/master/src/3d/tests/ELF.3d">full development</a>.)</p>
<p>Following this 16 byte array, the ELF header specifies the file type,
file version, followed by fields of our interest: <code class="docutils literal notranslate"><span class="pre">E_PHOFF</span></code>,
<code class="docutils literal notranslate"><span class="pre">E_SHOFF</span></code> (offsets of the two tables), and <code class="docutils literal notranslate"><span class="pre">E_PHNUM</span></code>, <code class="docutils literal notranslate"><span class="pre">E_SHNUM</span></code>
(number of entries in the two tables).</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="c">// ELF HEADER BEGIN</span>

E_IDENT          IDENT;
ELF_TYPE         E_TYPE       { E_TYPE != ET_NONE };

UINT16           E_MACHINE;
UINT32           E_VERSION    { E_VERSION == 1 };
ADDRESS          E_ENTRY;

<span class="c">//Program header table offset</span>
OFFSET           E_PHOFF;

<span class="c">//Section header table offset</span>
OFFSET           E_SHOFF;

UINT32           E_FLAGS;

UINT16           E_EHSIZE     { E_EHSIZE == <span class="k">sizeof</span> (<span class="k">this</span>) };

UINT16           E_PHENTSIZE;

<span class="c">//Number of program header table entries</span>
UINT16           E_PHNUM
  { (E_PHNUM == 0 &amp;&amp; E_PHOFF == 0) ||  <span class="c">//no Program Header table</span>
    (0 &lt; E_PHNUM &amp;&amp; E_PHNUM &lt; PN_XNUM &amp;&amp;
     <span class="k">sizeof</span> (<span class="k">this</span>) == E_PHOFF &amp;&amp;  <span class="c">//Program Header table starts immediately after the ELF Header</span>
     E_PHENTSIZE == <span class="k">sizeof</span> (PROGRAM_HEADER_TABLE_ENTRY)) };

UINT16           E_SHENTSIZE;

<span class="c">//Number of section header table entries</span>
UINT16           E_SHNUM
  { (E_SHNUM == 0 &amp;&amp; E_SHOFF == 0) ||  <span class="c">// no Section Header table</span>
    (0 &lt; E_SHNUM &amp;&amp; E_SHNUM &lt; SHN_LORESERVE &amp;&amp;
     E_SHENTSIZE == <span class="k">sizeof</span> (SECTION_HEADER_TABLE_ENTRY)) };

<span class="c">//Section header table index of the section names table</span>
UINT16           E_SHSTRNDX
  { (E_SHNUM == 0 &amp;&amp; E_SHSTRNDX == SHN_UNDEF) ||
    (0 &lt; E_SHNUM  &amp;&amp; E_SHSTRNDX &lt; E_SHNUM) };

<span class="c">// ELF HEADER END</span>
</pre></div>
</div>
<p>The constraint on <code class="docutils literal notranslate"><span class="pre">E_PHNUM</span></code> enforces that either the file has no
program header table (<code class="docutils literal notranslate"><span class="pre">E_PHNUM</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">E_PHOFF</span> <span class="pre">==</span> <span class="pre">0</span></code>) or the table
has non-zero number of entries and it starts immediately after the ELF
header (<code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">(this)</span></code> for the encapsulating struct type refers to
the ELF header shown here). We add similar constraints to <code class="docutils literal notranslate"><span class="pre">E_SHNUM</span></code>
but do not add any check for <code class="docutils literal notranslate"><span class="pre">E_SHOFF</span></code>, since unlike the
program header table, the section header table does not have a fixed
offset.</p>
<p>The ELF header is followed by the two optional tables. We specify
these optional tables using <code class="docutils literal notranslate"><span class="pre">casetype</span></code>. First, the program header
table:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">casetype</span> _PROGRAM_HEADER_TABLE_OPT (UINT16 PhNum,
                                    OFFSET ElfFileSize)
{
  <span class="k">switch</span> (PhNum)
  {
    <span class="k">case</span> 0:
      unit    Empty;
    <span class="k">default</span>:
      PROGRAM_HEADER_TABLE_ENTRY(ElfFileSize)    Tbl[:byte-size <span class="k">sizeof</span> (PROGRAM_HEADER_TABLE_ENTRY) * PhNum]
   }
} PROGRAM_HEADER_TABLE_OPT;
</pre></div>
</div>
<p>The type <code class="docutils literal notranslate"><span class="pre">PROGRAM_HEADER_TABLE_OPT</span></code> is parameterized by
the number of program header table entries, as specified in the ELF
header, and the size of the ELF file; the latter allows us to check
that the segments pointed to by the program header table entries are in
the file range.</p>
<p>In case <code class="docutils literal notranslate"><span class="pre">PhNum</span></code> is 0, the type is the empty <code class="docutils literal notranslate"><span class="pre">unit</span></code>
type. Otherwise, it is an <code class="docutils literal notranslate"><span class="pre">PROGRAM_HEADER_TABLE_ENTRY</span></code> array of
size <code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">(PROGRAM_HEADER_TABLE_ENTRY)</span> <span class="pre">*</span> <span class="pre">PhNum</span></code> bytes where the type
<code class="docutils literal notranslate"><span class="pre">PROGRAM_HEADER_TABLE_ENTRY</span></code> describes a segment:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _PROGRAM_HEADER_TABLE_ENTRY (OFFSET ElfFileSize)
{
  UINT32    P_TYPE;

  UINT32    P_FLAGS  { P_FLAGS &lt;= 7 };

  OFFSET    P_OFFSET;

  ADDRESS   P_VADDR;

  ADDRESS   P_PADDR;

  <span class="c">//The constraint checks that the segment is in the file range</span>
  UINT64    P_FILESZ  { P_FILESZ &lt; ElfFileSize &amp;&amp;
                        P_OFFSET &lt;= ElfFileSize - P_FILESZ };
  UINT64    P_MEMSZ;

  UINT64    P_ALIGN;
} PROGRAM_HEADER_TABLE_ENTRY;
</pre></div>
</div>
<p>The specification of the section header table is also a <code class="docutils literal notranslate"><span class="pre">casetype</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">casetype</span><span class="w"> </span><span class="nf">_SECTION_HEADER_TABLE_OPT</span><span class="w"> </span><span class="p">(</span><span class="n">OFFSET</span><span class="w"> </span><span class="n">PhTableEnd</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">OFFSET</span><span class="w"> </span><span class="n">ShOff</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">UINT16</span><span class="w"> </span><span class="n">ShNum</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">OFFSET</span><span class="w"> </span><span class="n">ElfFileSize</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">ShNum</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">      </span><span class="n">NO_SECTION_HEADER_TABLE</span><span class="p">(</span><span class="n">PhTableEnd</span><span class="p">,</span><span class="w"> </span><span class="n">ElfFileSize</span><span class="p">)</span><span class="w">                   </span><span class="n">NoTbl</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="n">SECTION_HEADER_TABLE</span><span class="p">(</span><span class="n">PhTableEnd</span><span class="p">,</span><span class="w"> </span><span class="n">ShOff</span><span class="p">,</span><span class="w"> </span><span class="n">ShNum</span><span class="p">,</span><span class="w"> </span><span class="n">ElfFileSize</span><span class="p">)</span><span class="w">        </span><span class="n">Tbl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="n">SECTION_HEADER_TABLE_OPT</span><span class="p">;</span>
</pre></div>
</div>
<p>We parameterize this type by the
offset where the program header table ends, the section header table
offset, number of section header table entries, and the size of the
file.</p>
<p>When number of entries is 0, the file does not have a section header
table, but we still need to check that the file contains enough bytes
after the program header table so that its total size is
<code class="docutils literal notranslate"><span class="pre">ElfFileSize</span></code>. <code class="docutils literal notranslate"><span class="pre">NO_SECTION_HEADER_TABLE</span></code> specifies such a type:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _NO_SECTION_HEADER_TABLE (OFFSET PhTableEnd,
                                         UINT64 ElfFileSize)
<span class="k">where</span> (PhTableEnd &lt;= ElfFileSize &amp;&amp; ElfFileSize - PhTableEnd &lt;= MAX_UINT32)
{
  UINT8        Rest[:byte-size (UINT32) (ElfFileSize - PhTableEnd)];
} NO_SECTION_HEADER_TABLE;
</pre></div>
</div>
<p>The checks in the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause ensure safety of the arithmetic
operations.</p>
<p>In case the section header table is non-empty, we specify (a) the
bytes between the end of the program header table and the beginning of
the section header table, (b) the section header table, and (c) final
check that end of the section header table is the end of the file.</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> _SECTION_HEADER_TABLE (OFFSET PhTableEnd,
                                      UINT64 ShOff,
                                      UINT16 ShNum,
                                      OFFSET ElfFileSize)
<span class="k">where</span> (PhTableEnd &lt;= ShOff &amp;&amp; ShOff - PhTableEnd &lt;= MAX_UINT32)
{
  UINT8        PHTABLE_SHTABLE_GAP[(UINT32) (ShOff - PhTableEnd)];

  SECTION_HEADER_TABLE_ENTRY(ShNum, ElfFileSize)    SHTABLE[:byte-size <span class="k">sizeof</span> (SECTION_HEADER_TABLE_ENTRY) * ShNum];

  <span class="c">// Check that we have consumed all the bytes in the file</span>
  unit        EndOfFile
  {:on-success <span class="k">var</span> x = <span class="k">field_pos</span>; <span class="k">return</span> (x == ElfFileSize); };
} SECTION_HEADER_TABLE;
</pre></div>
</div>
<p>The section header table, similar to the program header table, is an
array of entries.</p>
<p>Finally, the top-level ELF format:</p>
<div class="highlight-3d notranslate"><div class="highlight"><pre><span></span><span class="k">entrypoint</span>
<span class="k">typedef</span> <span class="k">struct</span> _ELF (UINT64 ElfFileSize)
{
  ... <span class="c">//ELF header as above</span>

  <span class="c">//Optional Program Header table</span>
  PROGRAM_HEADER_TABLE_OPT (E_PHNUM,
                            ElfFileSize)            PH_TABLE;

  <span class="c">//Optional Section Header Table</span>
  <span class="c">//Recall that the first argument is the end of the program header table</span>
  SECTION_HEADER_TABLE_OPT ((E_PHNUM == 0) ? E_EHSIZE : E_PHOFF + (<span class="k">sizeof</span> (PROGRAM_HEADER_TABLE_ENTRY) * E_PHNUM),
                            E_SHOFF,
                            E_SHNUM,
                            ElfFileSize)            SH_TABLE;
} ELF;
</pre></div>
</div>
<div class="section" id="integrating-elf-validator-in-existing-code">
<h2>Integrating ELF validator in existing code<a class="headerlink" href="#integrating-elf-validator-in-existing-code" title="Permalink to this headline">¶</a></h2>
<p>To compile the 3d specification to C code, download the latest
<a class="reference external" href="https://github.com/project-everest/everparse/releases">EverParse release</a> and compile
the 3d spec with the EverParse binary, e.g. for Windows:
<code class="docutils literal notranslate"><span class="pre">everparse.cmd</span> <span class="pre">--batch</span> <span class="pre">ELF.3d</span></code>. This command generates
<code class="docutils literal notranslate"><span class="pre">ELFWrapper.h</span></code> and <code class="docutils literal notranslate"><span class="pre">ELFWrapper.c</span></code> files, with the top-level
validation function as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOLEAN</span><span class="w"> </span><span class="nf">ElfCheckElf</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">___ElfFileSize</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>The actual validator implementation is generated in <code class="docutils literal notranslate"><span class="pre">ELF.c</span></code>. To
integrate these validators into existing C code, drop in these
generated <code class="docutils literal notranslate"><span class="pre">.c</span></code> and <code class="docutils literal notranslate"><span class="pre">.h</span></code> files
in the development and invoke <code class="docutils literal notranslate"><span class="pre">`ElfCheckElf</span></code> as necessary.</p>
</div>
</div>


           </div>
          </div>

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3d.html" class="btn btn-neutral float-left" title="3d: Dependent Data Descriptions for Verified Validation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>